<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ustb-806.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ustb-806.github.io/" rel="alternate" type="text/html" /><updated>2025-05-28T01:01:16+08:00</updated><id>https://ustb-806.github.io/feed.xml</id><title type="html">806 @ USTB</title><subtitle>北京科技大学「勤敏轩」学生创新实验室</subtitle><author><name>USTB-806</name></author><entry><title type="html">祝贺刁明轩、唐学彬、刘彦甫、刘畅在“2025ASC 世界大学生超级计算机竞赛”取得佳绩</title><link href="https://ustb-806.github.io/news/2025/05/asc/" rel="alternate" type="text/html" title="祝贺刁明轩、唐学彬、刘彦甫、刘畅在“2025ASC 世界大学生超级计算机竞赛”取得佳绩" /><published>2025-05-27T00:00:00+08:00</published><updated>2025-05-27T21:46:01+08:00</updated><id>https://ustb-806.github.io/news/2025/05/asc</id><content type="html" xml:base="https://ustb-806.github.io/news/2025/05/asc/"><![CDATA[<p>ASC 世界大学生超级计算机竞赛（ASC Student Supercomputer Challenge）由中国发起组织，并得到亚洲及欧美相关专家和机构支持，旨在推动国际超算青年人才培养与技术创新，现已成为全球规模最大的大学生超算赛事，累计吸引六大洲上万名学生参与。</p>
      <p>近日，2025ASC 世界大学生超级计算机竞赛（ASC25）顺利结束，本届赛事聚焦”AI for Science”前沿领域，首创性将 AlphaFold3 蛋白质预测（2024 诺贝尔化学奖）与 mRNA 疫苗 RNA 修饰技术（2023 诺贝尔医学奖）转化为核心赛题，构建”计算生物学 - 人工智能 - 超算系统”融合竞技平台。</p>
      <p>在为期两个月的预赛中，我校团队在 4000 瓦功耗约束下自行设计超级计算机系统，完成了 HPL、HPCG 基准测试优化、AlphaFold3 蛋白质结构预测推理加速及 RNA m5C 修饰位点检测等核心任务。来自全球的 300 余支队伍经过激烈角逐，最终，浙江大学、北京大学、清华大学等 25 支队伍脱颖而出获得一等奖。我校 ASC889 队、ASC1172 队、ASC888 队分别以第 28 名、第 31 名、第 78 名的成绩荣获二等奖，与我校代表队同获二等奖的还有来自电子科技大学等高校代表队。</p>
      <p>ASC1172 队刁明轩在 RNA m5C 检测赛题中，完成了从原始测序数据到高置信度 m5C 位点检测的全流程复现与优化。通过整合 Snakemake 工作流，基于 Conda 封装 hisat3n、samtools 等工具链，解决了参考基因组 C→T 索引构建、多步骤并行参数配置等关键问题，成功复现流程并验证初始结果。</p>
      <p class="text-center"><img src="https://blog-s3.806.group/post/2025-05-27-asc/01.jpg" alt="" />
        ASC1172 队伍合照（右一：刁明轩）</p>
      <p>ASC889 队在 AlphaFold3 推理优化上，主要通过软件层面的算法加速技术提升计算效率。通过采用 Flashattention2 优化注意力机制的计算路径，降低显存占用并加速矩阵运算；结合 DPM-Solver 改进扩散过程求解器的数值稳定性，减少迭代次数；同时实现了从 GPU 到 CPU 上的迁移，并启用了持久缓存优化。通过严格的测试和优化流程，最终在保障结构预测精度的前提下压缩了计算耗时。</p>
      <p>对于 m5C 修饰点检测，通过采用并行压缩、精细化线程分配及过滤条件调整，减少 I/O 瓶颈与计算负载。同时采取分治并行合并策略、惰性求值及向量化计算等优化数据读写与内存管理，综合实现性能提升。</p>
      <p class="text-center"><img src="https://blog-s3.806.group/post/2025-05-27-asc/02.jpg" alt="" />
        ASC889 队伍合照（从左至右，中间三位：刘彦甫、唐学彬、刘畅）</p>
      ]]></content><author><name>USTB-806</name></author><category term="竞赛" /><category term="系统部" /><category term="超算" /><summary type="html"><![CDATA[ASC 世界大学生超级计算机竞赛（ASC Student Supercomputer Challenge）由中国发起组织，并得到亚洲及欧美相关专家和机构支持，旨在推动国际超算青年人才培养与技术创新，现已成为全球规模最大的大学生超算赛事，累计吸引六大洲上万名学生参与。]]></summary></entry><entry><title type="html">第四次工业革命｜Cursor 体验报告</title><link href="https://ustb-806.github.io/blogs/2025/01/cursor-experience-review/" rel="alternate" type="text/html" title="第四次工业革命｜Cursor 体验报告" /><published>2025-01-20T00:00:00+08:00</published><updated>2025-01-21T21:08:31+08:00</updated><id>https://ustb-806.github.io/blogs/2025/01/cursor-experience-review</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2025/01/cursor-experience-review/"><![CDATA[<p>最开始听说 Cursor 这个工具的时候，是在知乎的某个回答里。当时以为这又是一个借着 AI 的热度，套了个 VSCode 的壳的圈钱软件，但当某一天在一次 OpenAI 的发布会上看到展示的员工也用 Cursor 的时后，我才改变了这个鲁莽的想法，决定亲自试一试。毕竟能让世界顶级大厂的人都愿意使用，那肯定是有他的过人之处。</p>
    <p>没想到，这一试，彻底颠覆了我的认知……</p>
    <h2 id="cursor-是什么">Cursor 是什么</h2>
    <p>简单来说，Cursor 是一个 VSCode 的 fork 版本，但是往里面加入了非常多 AI 相关的功能，包括更智能的代码补全，集成内部的 AI 对话框，以及本篇文章的重点内容——Composer 等等。</p>
    <p>你可能会问，这和 VSCode 自己的 Copilot 有什么区别呢？区别大着呢。</p>
    <p>简单概括 Cursor 和 Copilot 的区别：Cursor 的代码补全，不仅是能够补全后面的代码，更重要的是能<strong>对已有的代码进行修改</strong>。并且 Cursor 的上下文不仅局限于当前文件，而是整个工作区（文件夹）内的所有文件，甚至是电脑的剪切板，甚至是之前删掉的某些内容！Cursor 就好像有记忆力一般，用的越久，就越能够明白整个项目的结构。</p>
    <p>拿一个具体的例子来举例。</p>
    <p>我想在博客的 i18n 文件里插入一些新写好的内容。在 Cursor 里，只需要粘贴下来，然后输入第一个 <code class="language-plaintext highlighter-rouge">"</code> 号，接下来就只需要……不停按 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 就好了：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/1.gif" alt="1" /></p>
    <p>或者还可以调用 Cursor 的代码修改功能来实现。这个功能更适合想实现的目标比较复杂，代码补全没法直接通过上下文进行推测的情况。如果生成的有错误，还能通过代码补全自动发现并改正：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/2.gif" alt="2" /></p>
    <p>这些都还只是小场面。</p>
    <p>前段时间在打 OceanBase 比赛的时候，写 C++ 的大项目。C++ 的函数定义和函数实现是分别在 <code class="language-plaintext highlighter-rouge">.cpp</code> 和 <code class="language-plaintext highlighter-rouge">.h</code> 文件里的。如果想要增加一个函数的参数，就必须要在两个地方都进行修改。而且由于 C++ 继承的特性，经常会导致改了一个类的方法，就需要把他派生出来的所有类的方法都进行修改。</p>
    <p>使用 Cursor，只需要在 <code class="language-plaintext highlighter-rouge">.h</code> 文件中增加新的参数，切换到 <code class="language-plaintext highlighter-rouge">.cpp</code> 的实现时，会自动补全，并且还会把所有这个函数的调用都增加新的参数！这让我能够剩下大量的时间，专注于处理思路问题和解决 bug，而不是处理这些苦力活。</p>
    <p>但仅仅是这些功能的话，只是让我觉得这比 Copilot 聪明一些而已，但还不够为了他单独写一篇文章。真正让我觉得颠覆的功能是——Composer。</p>
    <h2 id="革命性的突破composer">革命性的突破——Composer</h2>
    <p>昨天晚上，我在 Bing 站点管理器里查看我的博客数据的时候，突然有个想法——在 GitHub workflow 弄一个脚本，每天凌晨的时候通过 Bing Url API 自动提交博客的最新 10 篇文章，这样就不会浪费每天的提交额度了。</p>
    <p>说干就干，我立刻翻开了 Bing 提交 API 的<a href="https://www.bing.com/webmasters/url-submission-api#APIs">说明文档</a>，但是……看不懂啊！对于一个完全没有写过后端，前端也只是在折腾博客的时候照猫画虎了解了一些的人来说，不花个几个小时系统学习一下这些知识，真的完全没法做到。</p>
    <p>正当想放弃的时候，我突然想到了 Composer。在这之前，除了新手教学以外，我还没用真正用过这个功能呢，那要不就试试吧！</p>
    <p>Composer 是一个增强版的代码修改功能，他能够读取并修改你的整个工作区的所有文件，甚至还能根据要求新建文件，可以说这才是完全体的 Copilot。</p>
    <p>稍微计划了一下，想要实现上述的功能，大概需要分成以下几个步骤：</p>
    <ol>
      <li>将 <code class="language-plaintext highlighter-rouge">/src/content/</code> 下的所有 <code class="language-plaintext highlighter-rouge">md,mdx</code> 格式的文件找出来；</li>
      <li>按照其 <code class="language-plaintext highlighter-rouge">frontmatter</code> 里的 <code class="language-plaintext highlighter-rouge">date</code> 属性进行排序；</li>
      <li>处理成合适的 url 链接；</li>
      <li>通过 Bing 提交 API 进行提交。</li>
    </ol>
    <p>开始行动！直接开门见山，告诉他帮我找出最新的 10 篇文章：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/3.gif" alt="3" /></p>
    <p>写得很快，但是报错了……尴尬，难道要出师未捷身先死了吗？</p>
    <p>把错误复制给他：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/4.gif" alt="4" /></p>
    <p>没想到，他通过项目的配置文件知道了我使用的是 ejs，一下子就解决了！有点惊叹。</p>
    <p>那么接下来是把路径处理成 url 的格式。写了个 <code class="language-plaintext highlighter-rouge">baseUrl</code> 代表域名，让他把路径修改成网址：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/5.gif" alt="5" /></p>
    <p>Cursor 竟然连 <code class="language-plaintext highlighter-rouge">baseUrl</code> 都自动补全了，真的震惊！</p>
    <p>但这还不够，文章的 url 是只有年份，没有后面的月和日的，再让他继续处理：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/6.gif" alt="6" /></p>
    <p>哎呀，又出错了，加上了年份但是没有正确去掉月和日。把错误反馈给他：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/7.gif" alt="7" /></p>
    <p>就这么反馈给他一下他就把错误处理好了……这效率太快了。</p>
    <p>那么现在网址处理完成了，接下来就是通过 API 给 Bing 提交。直接把刚刚 Bing 的 API 格式复制给他，让他帮我提交：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/8.gif" alt="8" /></p>
    <p>就这么两下，实现了……我刚刚倒上的水还没喝几口呢……</p>
    <p>但是看返回的信息好像没有成功提交？原来是今天的提交额度不够了，尴尬……那要不然改成一个一个提交，遇到限额满了就停止提交吧：</p>
    <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/9.gif" alt="9" /></p>
    <p>于是就这么完成了……最后只需要生成一个 GitHub workflow 脚本，让 GitHub 每天定时自动执行就好了。当然，这也只需要一句话的事情，这里就不展示了。</p>
    <p>就这么不到 10 分钟，Cursor 就完成了原本可能需要好几个小时甚至一两天才能实现的功能。而我甚至都不需要学会前端的各种知识，就能轻松实现。</p>
    <p>从此，我再也不需要因为一点小小的需求，而去学习大量无关紧要的知识了。唯一要做的就是把任务进行拆分，然后依次告诉 Cursor 让他帮我实现，遇到错误了就再反馈给他就好了。我甚至不需要复制粘贴……</p>
    <h2 id="现状与未来">现状与未来</h2>
    <p>我敢说，Cursor 是我到目前为止，唯二觉得能算得上是生产力的 AI 工具了，另一个是 ChatGPT。Cursor 利用现在大模型庞大的知识储备，让我能够迅速补上知识层面的漏洞。从此之后我写代码，就好像战场上的指挥官，我只需要指挥，苦力基本上可以依靠 AI 来实现。</p>
    <p>现在 Cursor 支持的最高的模型还仅仅是 claude-3.5，不敢想象如果以后能接入 o1 等更高级的模型，Cursor 的能力会发展成什么样。</p>
    <p>其实相较于图片，视频，音乐等领域，我觉得代码生成才是大模型最能崭露头角的地方，同时也是最容易替代人工的地方。</p>
    <p>虽然 DALL-E、Sora 等模型能生成出来很多高质量的作品，但还是被我们吐槽一眼 AI。究其原因，我觉得还是 AI 生成的过程依旧只是照猫画虎，它并不能理解图片中的各种物理规律，更别说是视频了。</p>
    <p>而且在这种较为「艺术」的领域，我们欣赏一部作品，欣赏的是作者创作这个作品时候的想法，又或者是欣赏某个作者的特殊的风格。我会因为一部电影是诺兰导演的而特意去电影院观看，映后会和朋友讨论片中的各种细节与伏笔，感受诺兰想通过镜头转达给我们的思考。但我若是看到一部 AI 生成的电影，我只会说「哇，这个 AI 好厉害」。</p>
    <p>但是在代码这个领域，目标只要一个——写出符合要求的代码，而这正是现在的 AI 最擅长的。</p>
    <p>人和机器最大的不同，是<em>人有人性</em>。通俗一点来讲，就是人会有喜怒哀乐，会有爱恨情仇，会有希望梦想，会有诗和远方……这些，这是机器不具备的。但很可惜，或许是因为社会的压力，又或者是因为其他原因，有些人已经失去了这部分能力，变成了一个活着的机器了。</p>
    ]]></content><author><name>Nelson Boss</name></author><category term="教程" /><category term="Cursor" /><category term="AI" /><summary type="html"><![CDATA[最开始听说 Cursor 这个工具的时候，是在知乎的某个回答里。当时以为这又是一个借着 AI 的热度，套了个 VSCode 的壳的圈钱软件，但当某一天在一次 OpenAI 的发布会上看到展示的员工也用 Cursor 的时后，我才改变了这个鲁莽的想法，决定亲自试一试。毕竟能让世界顶级大厂的人都愿意使用，那肯定是有他的过人之处。]]></summary></entry><entry><title type="html">如何从零开始可视化一首音乐？</title><link href="https://ustb-806.github.io/blogs/2024/12/visualize-spectumn/" rel="alternate" type="text/html" title="如何从零开始可视化一首音乐？" /><published>2024-12-14T00:00:00+08:00</published><updated>2024-12-14T14:08:51+08:00</updated><id>https://ustb-806.github.io/blogs/2024/12/visualize-spectumn</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/12/visualize-spectumn/"><![CDATA[<p>最近换上了 ArchLinux，体验了众多美观的 TUI 应用。其中我认为最酷炫的当属 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 这个音乐播放器了。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/ncmpcpp_demo.gif" alt="ncmpcpp 的可视化音频效果" /></p>
  <p>日常办公时把它放在屏幕角落，就会感觉工作环境变得更有趣了。这也让我对它的实现产生了巨大的好奇心，于是我决定探索一下它是如何实现的。</p>
  <p>本文将深入底层，从音频编码开始讲起，探究 <code class="language-plaintext highlighter-rouge">wav</code> 格式的音频文件是如何被解析的，然后再讲解如何通过傅立叶变换将音频信号转换为频谱图，最后再着手实现。</p>
  <h1 id="音频编码">音频编码</h1>
  <h2 id="声波">声波</h2>
  <p>中学物理教过我们，声音是一种机械波，由物体振动产生，通过介质传播。当波通过介质传递到耳朵时，耳膜会随之振动，我们才能听到声音。</p>
  <p>声波会引起麦克风（注：这里以动圈式麦克风为例）传感器中的振膜振动，振膜与被磁铁包围着住的线圈相连，根据法拉第定律和楞次定律，振膜振动会使磁场中线圈移动而产生感应电流。此时，只需要监测线圈两极的电压即可得到声音的波形图。机械振动就被转换为了电压信号。</p>
  <p>我们现在得到的是连续的模拟信号，还需要将其转换成计算机可识别的离散的数字信号。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/image.png#full" alt="连续的模拟信号。图片来源@cjting" /></p>
  <p>这时候，我们需要对信号进行模数转换（ADC）。AD 芯片每隔一段时间（几微秒）对波形图打点采样，得到每一个点的电压值，然后量化为二进制数，最后再进行编码，我们就得到了音频波形数据。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/image-1.png#full" alt="采样。图片来源@cjting" /></p>
  <h2 id="wav-格式">WAV 格式</h2>
  <p>和图像、视频一样，音频编码格式也主要分为两大类：有损压缩和无损压缩格式。</p>
  <p><code class="language-plaintext highlighter-rouge">wav</code> 就是一种典型的无损压缩格式，它是由微软和 IBM 共同开发的一种音频文件格式。它被称为“波形文件”，它也是相对好理解的一个音频格式。</p>
  <p>一个完整的 <code class="language-plaintext highlighter-rouge">wav</code> 文件必须包含两个区块：<code class="language-plaintext highlighter-rouge">Format Chunk</code> 和 <code class="language-plaintext highlighter-rouge">Data Chunk</code></p>
  <p>下面是一个包含了以上两个 Chunk 的 WAV 文件的例子：</p>
  <pre><code class="language-plain"> __________________________
| RIFF WAVE Chunk	   |
|   groupID  = 'RIFF'      |
|   riffType = 'WAVE'      |
|    __________________    |
|   | Format Chunk     |   |
|   |	ckID = 'fmt '  |   |
|   |__________________|   |
|    __________________    |
|   | Sound Data Chunk |   |
|   |	ckID = 'data'  |   |
|   |__________________|   |
|__________________________|
</code></pre>
  <p><code class="language-plaintext highlighter-rouge">Format Chunk</code> 包含了重要的描述波形的参数：</p>
  <ul>
    <li>采样率（Sample Rate）：每秒采样模拟信号的次数</li>
    <li>采样宽度（Sample Width）：每个采样点的位数</li>
    <li>声道数量（Audio Channels）</li>
    <li>采样帧总数（Sample Frame）</li>
    <li>压缩方式（Compression Type）</li>
  </ul>
  <p><code class="language-plaintext highlighter-rouge">Data Chunk</code> 包含了实际的波形数据，这些数据由一连串的采样帧组成，按时间顺序排列。</p>
  <p>一个采样点表示一次采样内声音的振幅值。采样点位数越高，可表示的值的范围就越大，音频的质量就越好，但是文件的大小也就越大。一个采样帧包含了一次采样的所有声道的采样点。比如，我有左右两个声道，每个声道有 16 位的采样点，那么一个采样帧就包含了 32 位的数据。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/image-2.png" alt="" /></p>
  <p>在 Python 中，我们可以使用 <code class="language-plaintext highlighter-rouge">wave</code> 模块来读取 <code class="language-plaintext highlighter-rouge">wav</code> 文件：</p>
  <p>440hz_16bit_5s.wav:</p>
  <audio controls="" src="https://blog.soulter.top/images/visualize-music/440hz_16bit_5s.wav" title="440hz_16bit_5s"></audio>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>

<span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">getparams</span><span class="p">())</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
</code></pre>
    </div>
  </div>
  <p>输出如下内容：</p>
  <pre><code class="language-plain">_wave_params(nchannels=1, sampwidth=2, framerate=44100, nframes=220500, comptype='NONE', compname='not compressed')
b'\x00\x00\x8d\x05\x13\x0b\x8e\x10\xf9\x15M\x1b\x87 \xa0%\x93*Z/\xf33W8\x82&lt;p@\x1eD\x88G\xa9J\x7fM\x07P?R'
</code></pre>
  <p>这段音频有一个声道，每个采样点占 2 byte，采样率为 44100，总共有 220500 个采样帧。220500 / 44100 = 5 秒。</p>
  <p>后面读出的采样帧字符串是一段十六进制转义序列，我们可以使用 <code class="language-plaintext highlighter-rouge">struct</code> 模块来解析：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>
<span class="kn">import</span> <span class="n">struct</span>

<span class="k">def</span> <span class="nf">read_wave</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">nframes</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">getnframes</span><span class="p">()</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="n">nframes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">&lt;</span><span class="si">{</span><span class="n">nframes</span><span class="si">}</span><span class="s">h</span><span class="sh">'</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="nf">read_wave</span><span class="p">(</span><span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
</code></pre>
    </div>
  </div>
  <p>在这里我们解析了前 10 个采样帧，<code class="language-plaintext highlighter-rouge">h</code> 表示短整型，<code class="language-plaintext highlighter-rouge">&lt;</code> 表示小端序。WAVE 文件采用小端序来存储数据。</p>
  <p>输出如下：</p>
  <pre><code class="language-plain">(0, 1421, 2835, 4238, 5625, 6989, 8327, 9632, 10899, 12122)
</code></pre>
  <p>我们发现这一段数字是逐渐增加的，很符合波形的特点。截取前 0.05 秒的波形，然后根据时间绘制波形图：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725975340572.png" alt="" /></p>
  <p>可以发现这是一个正弦波。横轴为时间，纵轴为振幅。由于这段音频的采样宽度为 16 位，所以振幅的范围是 $[-2^{15}, 2^{15}-1]$，即 $[-32768, 32767]$。</p>
  <p>到目前为止，我们已经成功地将音频文件解析为了波形数据，并且成功可视化出了声波振幅随时间变化的波形图。不过，我们想象中的 440Hz 的“可视化图像”应该是那种“只有一个峰”的频谱图，和一开始提到的 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果是一样的。那如何将这种数据转化成频谱图呢？这里，我们需要用到傅立叶变换。</p>
  <h2 id="快速傅立叶变换fft">快速傅立叶变换（FFT）</h2>
  <p>傅立叶变换是一种将信号从时域转换到频域的方法，它可以将一个信号分解为一系列不同频率的正弦波。快速傅立叶变换（FFT）是一种计算傅立叶变换的高效算法。下面是快速傅立叶变换的 Python 实现：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">even</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmath</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2j</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">odd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> \
           <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
</code></pre>
    </div>
  </div>
  <p>它的输入是一系列采样点的振幅值，输出是一系列复数，表示不同频率的正弦波的振幅和相位。让我们把上面的 440Hz 的波形数据输入到这个函数中：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="p">[</span>
    <span class="p">(</span><span class="mi">503643</span><span class="o">+</span><span class="mf">0j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">68801.16613674666</span><span class="o">+</span><span class="mf">116234.4683635989j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">23890.51738479154</span><span class="o">+</span><span class="mf">53037.36938852984j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">16335.061327176663</span><span class="o">+</span><span class="mf">34280.395464007364j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">13741.719659027507</span><span class="o">+</span><span class="mf">24979.846914594244j</span><span class="p">),</span>
    <span class="bp">...</span>
<span class="p">]</span>
</code></pre>
    </div>
  </div>
  <h2 id="可视化频谱">可视化频谱</h2>
  <p>我们将原始波形数据应用于 FFT，然后将得到的复数值转换为其模长，并进行归一化：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="n">spectrum_complex</span><span class="p">,</span> <span class="n">max_value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">将频谱复数转换为振幅，并归一化</span><span class="sh">'''</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">abs</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum_complex</span><span class="p">]</span>
    <span class="n">max_spectrum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">spectrum</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># 防止除以 0
</span>    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">max_value</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">/</span> <span class="n">max_spectrum</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="p">]</span>

<span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">512</span><span class="p">]))[:</span><span class="mi">20</span><span class="p">]</span>
</code></pre>
    </div>
  </div>
  <p>输出：</p>
  <pre><code class="language-plain">[0, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
  <p>是不是有感觉了？！我们采用了前 512 个采样帧的频谱数据，并将它们缩放到 0-10 的范围内，然后取前 20 个频率的振幅值。我们可以使用 <code class="language-plaintext highlighter-rouge">curses</code> 模块来绘制频谱图：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="kn">import</span> <span class="n">curses</span><span class="p">,</span> <span class="n">time</span>

<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="sh">"</span><span class="s">#</span><span class="sh">"</span> <span class="o">*</span> <span class="n">freq</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>

<span class="c1"># （这个 main 函数不是最终版本！）
</span><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">512</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>
        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[:</span><span class="mi">40</span><span class="p">])</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">wrapper</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</code></pre>
    </div>
  </div>
  <p>这里，我们对音频数据进行了分帧处理，每帧 2048 个采样帧，帧移 512 个采样帧。然后我们计算每一帧的频谱，并绘制频谱图。我们可以看到频谱图随时间变化的效果。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726126824224.png" alt="" /></p>
  <p>现在还有一个小问题，就是这个频谱图的播放时间 (约 8s) 远远高于了实际音乐的播放时间 5s。这是由于我们在每次渲染时，将睡眠时间固定为了 0.05s。没有考虑实际音乐的播放速度和一次循环所用到的采样帧占总采样帧的比例。并且，计算 FFT 和渲染频谱图也是会消耗时间的。</p>
  <p>这也很好解决，为了使可视化跟上音乐的播放速度，我们需要知道音乐的总长度、每一个可视化帧应该的播放时间、可视化帧运算和渲染花费的时间，然后动态调整睡眠时间：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1024</span>

    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>
        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[:</span><span class="mi">40</span><span class="p">],</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span><span class="p">,</span> <span class="n">total_duration</span><span class="p">)</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="c1"># 将可视化帧播放时间剪去运算渲染消耗的时间，来达到自适应。
</span>        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="p">(</span><span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)))</span>
</code></pre>
    </div>
  </div>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726128923283.png" alt="" /></p>
  <p>接下来，我们来优化这个播放器。比如：不同振幅采用不同的颜色、把频谱图横过来、平滑可视化帧之间的振幅。让我们来进行优化</p>
  <p>按照缩放振幅最大值的 0.2、0.4、0.6 倍分割成 4 段，分别采用淡蓝、白、绿、黄颜色区分。</p>
  <p>初始化 curses 的颜色对：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">init_colors</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">start_color</span><span class="p">()</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_CYAN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_WHITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_GREEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">MAX_VALUE</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.6</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre>
    </div>
  </div>
  <p>渲染：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">max_y</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">[:</span><span class="n">max_x</span><span class="p">]</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># 水平展示频谱
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

    <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">curr</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> / </span><span class="si">{</span><span class="n">total</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> s</span><span class="sh">'</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>
</code></pre>
    </div>
  </div>
  <p>然后，我们采用 EMA（移动指数平均）来实现平滑数据。</p>
  <p>EMA 的计算公式为：</p>
  <p>[EMA(t) = (1 - \alpha) \cdot EMA(t-1) + \alpha \cdot x(t)]</p>
  <p>其中 $\alpha$ 为平滑系数，$x(t)$ 为当前值，$EMA(t-1)$ 为上一次的平滑值。</p>
  <p>我们只需要记录上一次的平滑后的频谱值，然后在每一帧的频谱值上应用 EMA 即可。</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>
<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">haruhikage.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">4096</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">2048</span>

    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="n">audio_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">play_audio</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">file_name</span><span class="p">,))</span>
    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

    <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">ema_alpha</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">previous_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># 应用 EMA
</span>            <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ema_alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">ema_alpha</span> <span class="o">*</span> <span class="n">curr</span><span class="p">)</span> <span class="k">for</span> <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">previous_spectrum</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)]</span>

        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span><span class="p">,</span> <span class="n">total_duration</span><span class="p">)</span>
        <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="p">(</span><span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)))</span>

    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
</code></pre>
    </div>
  </div>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726145469076.png" alt="" /></p>
  <p>挺像回事了 hhh。最后，我们再对整个代码进行一轮优化。</p>
  <ol>
    <li>
      <p>第零，既然这是一个可以可视化音频的工具，为什么不能同时播放音乐呢？于是我用了 <code class="language-plaintext highlighter-rouge">simpleaudio</code> 模块，在子线程中同步播放音乐。</p>
    </li>
    <li>
      <p>第一，上面的代码没有考虑窗口自适应，我们需要在每一次循环中都取一次窗口大小 <code class="language-plaintext highlighter-rouge">max_x</code> 和 <code class="language-plaintext highlighter-rouge">max_y</code>，当窗口发生变化时重新计算 <code class="language-plaintext highlighter-rouge">colors</code> 列表。</p>
    </li>
    <li>
      <p>第二，现在的计算方式是一次性将 4096 个采样帧都进行 EMA 计算，实际我们只需要将窗口的 <code class="language-plaintext highlighter-rouge">max_x</code> 个采样帧进行 EMA 计算和存储即可。</p>
    </li>
    <li>
      <p>第三，我通过和实际音乐播放的时间比对发现，整个渲染部分还是会有延迟（基本上每秒会有 0.003 秒的延迟），如果任由其累加，到了后面，实际的音频播放会和可视化频谱有很大的错位。我直接计算了实际播放时间和可视化帧时间的差，将其作为 <code class="language-plaintext highlighter-rouge">delay</code>，然后在 time.sleep() 时直接减去这个 <code class="language-plaintext highlighter-rouge">delay</code>，这样就能在单次帧渲染时把 delay 给消除。</p>
    </li>
    <li>
      <p>第四，测试发现很多振幅低的频率在频谱图中几乎不可见，这是因为我们采用的是线性归一化，高振幅的频率会压缩低振幅的频率。我们可以换成平方根归一化，这样可以减少高低频率振幅的差距。</p>
    </li>
    <li>
      <p>第五，我发现渲染帧率太高了，而帧之间的振幅变化又太快，导致频谱图看起来很闪烁。于是我设置了一个固定的帧率 <code class="language-plaintext highlighter-rouge">fps</code> 和频谱数据缓冲区，其大小为 <code class="language-plaintext highlighter-rouge">frame_duration / (1/fps)</code>，频谱数据先放入缓冲区，当缓冲区满时全部取出，并求平均值，然后再进行 EMA 计算和渲染。</p>
      <blockquote>
        <p>后续发现其实调大 <code class="language-plaintext highlighter-rouge">hop_size</code> 就行。想复杂了 = =</p>
      </blockquote>
    </li>
  </ol>
  <p>优化后的完整代码如下：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>
<span class="kn">import</span> <span class="n">struct</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="kn">import</span> <span class="n">cmath</span>
<span class="kn">import</span> <span class="n">curses</span>
<span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">threading</span>
<span class="kn">import</span> <span class="n">simpleaudio</span> <span class="k">as</span> <span class="n">sa</span>

<span class="k">def</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">wf</span><span class="p">:</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getnchannels</span><span class="p">()</span>
        <span class="n">sample_width</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getsampwidth</span><span class="p">()</span>
        <span class="n">frame_rate</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getframerate</span><span class="p">()</span>
        <span class="n">num_frames</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getnframes</span><span class="p">()</span>

        <span class="n">raw_data</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="n">num_frames</span><span class="p">)</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="n">num_frames</span> <span class="o">*</span> <span class="n">num_channels</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">&lt;</span><span class="si">{</span><span class="n">total_samples</span><span class="si">}</span><span class="s">h</span><span class="sh">"</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">num_channels</span><span class="p">)]</span>  <span class="c1"># 只取一个声道
</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span>

<span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">even</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmath</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2j</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">odd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> \
           <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="n">spectrum_complex</span><span class="p">,</span> <span class="n">max_y</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">将频谱复数转换为振幅，并归一化</span><span class="sh">'''</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="nf">int</span><span class="p">((</span><span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>  <span class="mf">0.8</span><span class="p">)</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">abs</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum_complex</span><span class="p">]</span>
    <span class="n">max_spectrum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">spectrum</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># return [int(max_y * freq / max_spectrum) for freq in spectrum]
</span>    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">max_y</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">max_spectrum</span><span class="p">))</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">play_audio</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="n">wave_obj</span> <span class="o">=</span> <span class="n">sa</span><span class="p">.</span><span class="n">WaveObject</span><span class="p">.</span><span class="nf">from_wave_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    <span class="n">play_obj</span> <span class="o">=</span> <span class="n">wave_obj</span><span class="p">.</span><span class="nf">play</span><span class="p">()</span>
    <span class="n">play_obj</span><span class="p">.</span><span class="nf">wait_done</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">init_colors</span><span class="p">():</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">start_color</span><span class="p">()</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_CYAN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_WHITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_GREEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">max_y</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">max_y</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.6</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ema</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
    <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">prev</span><span class="p">):</span>
            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="c1"># 自适应窗口大小可能会导致 prev 长度小于 curr
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">new</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">haruhikage.wav</span><span class="sh">'</span>
    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1024</span>
    <span class="n">ema_alpha</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1"># EMA 的 alpha
</span>    <span class="n">fps</span> <span class="o">=</span> <span class="mi">40</span>

    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="n">audio_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">play_audio</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">file_name</span><span class="p">,))</span>
    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="n">play_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

    <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># 上一次的频谱
</span>    <span class="n">last_max_y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span> <span class="c1"># 上一次的窗口大小
</span>    <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">last_max_y</span><span class="p">)</span>

    <span class="n">cached_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ideal_frame_time</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">fps</span>
    <span class="n">cached_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">ideal_frame_time</span> <span class="o">//</span> <span class="n">frame_duration</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

        <span class="c1"># 自适应窗口大小
</span>        <span class="n">max_y</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_y</span> <span class="o">!=</span> <span class="n">last_max_y</span><span class="p">:</span>
            <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">max_y</span><span class="p">)</span>
            <span class="n">last_max_y</span> <span class="o">=</span> <span class="n">max_y</span>

        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">])[:</span><span class="n">max_x</span><span class="p">],</span> <span class="n">max_y</span><span class="p">)</span>

        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">cached_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cached_size</span><span class="p">:</span>
            <span class="c1"># 求平均
</span>            <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cached_list</span><span class="p">)]</span>
            <span class="n">cached_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># 应用 EMA
</span>            <span class="k">if</span> <span class="n">previous_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">ema</span><span class="p">(</span><span class="n">ema_alpha</span><span class="p">,</span> <span class="n">previous_spectrum</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)</span>
            <span class="c1"># 渲染频谱
</span>            <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)</span>

            <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cached_list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

        <span class="n">_render_time</span> <span class="o">=</span> <span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="n">_frame_time</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span>
        <span class="n">_actual_frame_time</span> <span class="o">=</span> <span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">play_start_time</span>
        <span class="n">_delay</span> <span class="o">=</span> <span class="n">_actual_frame_time</span> <span class="o">-</span> <span class="n">_frame_time</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="s">(</span><span class="si">{</span><span class="n">_actual_frame_time</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">s) </span><span class="si">{</span><span class="n">_frame_time</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> / </span><span class="si">{</span><span class="n">total_duration</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> s delay: </span><span class="si">{</span><span class="p">(</span><span class="n">_delay</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s render: </span><span class="si">{</span><span class="n">_render_time</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s frame: </span><span class="si">{</span><span class="n">frame_duration</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s</span><span class="sh">'</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>

        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="n">_render_time</span> <span class="o">-</span> <span class="n">_delay</span><span class="p">))</span>

    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">wrapper</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</code></pre>
    </div>
  </div>
  <p>我们用它来播放一下来自 CHYCHIC 的 <code class="language-plaintext highlighter-rouge">haruhikage.wav</code>：</p>
  <p>（该 demo 不是最终版本！下面还有两个优化！！）</p>
  <video controls="" src="https://blog.soulter.top/images/visualize-music/demo_cry.mp4" title="Title" style="width: 100%"></video>
  <p>相比于 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果，还有很多地方需要优化，比如多声道支持、更平滑的频谱图。</p>
  <p>（下面是 Update，已经更新了多声道支持）</p>
  <h2 id="更丝滑的频谱图">更丝滑的频谱图</h2>
  <p>查阅了相关资料，突然发现我们可以设置两个 EMA Alpha，一个是当 prev_spectrum 小于 curr_spectrum 时的 alpha1，一个是当 prev_spectrum 大于 curr_spectrum 时的 alpha2。前者可以让频谱图更快地上升，后者可以让频谱图更慢地下降。这样就可以让频谱图更加丝滑了。</p>
  <p>主函数：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">().</span><span class="nb">file</span>
    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1600</span>

    <span class="c1"># The EMA alpha. Means the weight of the **previous** spectrum.
</span>    <span class="n">ema_alpha_down</span> <span class="o">=</span> <span class="mf">0.93</span> <span class="c1"># when previous value &gt; current value
</span>    <span class="n">ema_alpha_up</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># when previous value &lt;= current value
</span>
    <span class="c1"># ...
</span></code></pre>
    </div>
  </div>
  <p>EMA 函数：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">ema</span><span class="p">(</span><span class="n">alpha_down</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_up</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">prev</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">curr</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">Exponential Moving Average</span><span class="sh">'''</span>
    <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">prev</span><span class="p">):</span>
            <span class="c1"># dynamically adjust the size of terminal window may cause the length of prev and curr to be different
</span>            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">alpha_down</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_down</span><span class="p">)</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">alpha_up</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_up</span><span class="p">)</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">new</span>
</code></pre>
    </div>
  </div>
  <p>效果如下：</p>
  <video controls="" src="https://blog.soulter.top/images/visualize-music/demo2.mp4" title="demo2" style="width: 100%"></video>
  <p>可以发现，在鼓点来时，频谱图上升得很快，而在鼓点过后，频谱图下降得很慢。这样就显得更加丝滑！</p>
  <h2 id="更更丝滑的频谱图">更更丝滑的频谱图</h2>
  <p>在前面的实现中，我们默认绘图的字符是 “█”，然而，它在 unicode 中叫作 “Full block”。它还有 7 个兄弟：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">▁</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▂</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▃</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▄</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▅</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▆</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▇</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">█</span><span class="sh">'</span><span class="p">]</span>
</code></pre>
    </div>
  </div>
  <p>我们可以借此实现更加丝滑的频谱图。</p>
  <p>首先，scale 的最大值可以直接乘以 <code class="language-plaintext highlighter-rouge">len(blocks)</code>：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="n">last_scale_max_val</span> <span class="o">=</span> <span class="nf">int</span><span class="p">((</span><span class="n">max_y</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">)</span>
</code></pre>
    </div>
  </div>
  <p>然后我们的振幅范围就在 [0, last_scale_max_val] 之间。</p>
  <p>在绘图时，前 <code class="language-plaintext highlighter-rouge">val // len(blocks)</code> 个字符使用 <code class="language-plaintext highlighter-rouge">Full Block</code>，最后一个字符使用 <code class="language-plaintext highlighter-rouge">blocks[val % len(blocks)]</code>。</p>
  <p>我们稍加修改 <code class="language-plaintext highlighter-rouge">draw_spectrum</code> 函数：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">full_1</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">freq</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
        <span class="n">full_2</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
        <span class="n">left_1</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">left_2</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>

        <span class="c1"># draw the full blocks
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">full_1</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if the audio file only has one channel, draw the same spectrum for the other channel
</span>                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="k">continue</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">full_2</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

        <span class="c1"># draw the left blocks
</span>        <span class="k">if</span> <span class="n">left_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">left_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_2</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_2</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</code></pre>
    </div>
  </div>
  <video controls="" src="https://blog.soulter.top/images/visualize-music/demo2.5.mp4" title="demo2.5" style="width: 100%"></video>
  <p>OHHH! 看样子更加丝滑了！… 怎么下面的频谱图变得断断续续了？</p>
  <p>因为我们的 blocks 使用的 unicode 字符的填充是从下往上的，因此就会导致在绘制下半部分频谱图时，末端使用的字符方向不对，导致 full block 和其他 block 之间有间隙。怎么解决呢？似乎 unicode 字符没有从上往下填充的字符。</p>
  <p>一个好办法是创造一个 <code class="language-plaintext highlighter-rouge">colors_reverse</code>，其颜色配置和 <code class="language-plaintext highlighter-rouge">colors</code> 相反，比如 colors 中一个 color 的前景是淡蓝色，背景是黑色，那么 colors_reverse 中这个 color 的前景就是黑色，背景就是淡蓝色。然后我们在绘制频谱图时，将下半部分的频谱图字符颜色设置为 <code class="language-plaintext highlighter-rouge">colors_reverse</code> 中的某个。</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>
<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># ...
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># ...
</span>        <span class="c1"># draw the left blocks
</span>        <span class="k">if</span> <span class="n">left_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors_reverse</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">left_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_2</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors_reverse</span><span class="p">[</span><span class="n">full_2</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</code></pre>
    </div>
  </div>
  <p>效果如下：</p>
  <video controls="" src="https://blog.soulter.top/images/visualize-music/demo3.mp4" title="demo3" style="width: 100%"></video>
  <p>快赶上 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果了！</p>
  <p>后面有时间再继续优化喵。</p>
  <h2 id="附直观理解傅立叶变换">附：直观理解傅立叶变换</h2>
  <p>上文讲到傅立叶变换的基本思想是将一个信号分解为一系列正弦波的叠加。</p>
  <p>拿方波举个例子，下图是一个 5Hz 的方波和一个 5Hz 的正弦波</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976721919.png" alt="" /></p>
  <p>是不是差距蛮大的？那如果我们将 2 个正弦波叠加在一起呢？</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976743585.png" alt="" /></p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976828380.png" alt="" /></p>
  <p>我们会发现，更像方波了。随着我们叠加的正弦波越来越多，我们的波形就会越来越接近方波。</p>
  <p>我们日常听的音乐就是由大量不同频率的正弦波叠加而成的，而傅立叶变换就能够将其分解为一系列不同频率的波。</p>
  <p>为了直观理解傅立叶变换，我参考了 <a href="https://www.youtube.com/watch?v=spUNpyF58BY">@3b1b 的视频</a> 里的方法。</p>
  <p>还是以 5Hz 的正弦波为例。</p>
  <p>440hz_16bit_5s.wav:</p>
  <audio controls="" src="https://blog.soulter.top/images/visualize-music/440hz_16bit_5s.wav" title="440hz_16bit_5s"></audio>
  <p>我们在复平面上从实数轴正半轴开始逆时针转动一个向量：在任意时刻下，向量的模长等于正弦波的振幅，向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">1 Hz</code>，以此绘制得到一个图：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725978427291.png" alt="" /></p>
  <p>它的质心用红点标了出来。</p>
  <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">4.2 Hz</code> 时：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726146180844.png" alt="" /></p>
  <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">4.3 Hz</code> 时：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726146113953.png" alt="" /></p>
  <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">5 Hz</code> 时：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725979910845.png" alt="" /></p>
  <p>有没有发现什么？我们绘制出质心与原点的距离随向量的移动速度变化的图（我们称为“缠绕图像”）：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725979995976.png" alt="" /></p>
  <p>在接近 <code class="language-plaintext highlighter-rouge">5 Hz</code> 时，值最大！！</p>
  <p>同样，我们将 5Hz + 15Hz 的正弦波叠加在一起，再次绘制这个图：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725980156817.png" alt="" /></p>
  <p>极大值点同样出现在 5Hz 和 15Hz 处。</p>
  <p>发生了什么？让我们从公式的角度出发，来解释这个现象。</p>
  <p>由欧拉公式，我们知道，一个圆周运动可以表示为：
    \(e^{2\pi i f t}\)</p>
  <p>其中 $f$ 为频率，$t$ 为时间。</p>
  <p>上述像花一样的缠绕图像可以表示为：</p>
  <p>[g(t) e^{2\pi i t}]</p>
  <p>其中，g(t) 为正弦函数：$ g(t) = \sin(2\pi 5 t) $，也就是一个振幅随时间变化的方程。</p>
  <p>我们需要描述的是其质心在复平面上的坐标的模随时间变化的方程。因此随机取 $N$ 个时间点，计算其质心的坐标，然后取其模长的平均值。</p>
  <table>
    <tbody>
      <tr>
        <td>[\frac{1}{N} \sum_{n=1}^{N}</td>
        <td>g(t_n) e^{2\pi i t_n}</td>
        <td>]</td>
      </tr>
    </tbody>
  </table>
  <p>类似这样，我们对函数作积分，就得到了傅立叶变换：</p>
  <table>
    <tbody>
      <tr>
        <td>[\int_{t_1}^{t_2}</td>
        <td>g(t) e^{2\pi i t}</td>
        <td>dt]</td>
      </tr>
    </tbody>
  </table>
  <p>其值表示的是在 $t_1$ 到 $t_2$ 时刻下，频率为 $f$ 的声波的相对振幅。如果某一个频率的波的强度很大，那么值也会越大。</p>
  <p>看文字不如直接看 <a href="https://www.youtube.com/watch?v=spUNpyF58BY">@3b1b 的视频</a>。</p>
  <h2 id="总结">总结</h2>
  <p>本文介绍了 <code class="language-plaintext highlighter-rouge">wav</code> 的编码结构和傅立叶变换在音频可视化中的应用，并手搓了一个 TUI 的支持频谱可视化的音频播放器。最后，我们通过直观的方式理解了傅立叶变换的基本原理。</p>
  <p>代码开源在了 <a href="https://github.com/soulter/wav-spectrum-visualizer">GitHub</a>，可以去玩玩。</p>
  <h2 id="参考文献">参考文献</h2>
  <p>[1] WAVE File Format. https://web.archive.org/web/20140221054954/http://home.roadrunner.com/~jgglatt/tech/wave.htm</p>
  <p>[2] But what is the Fourier Transform? A visual introduction. https://www.youtube.com/watch?v=spUNpyF58BY</p>
  <p>[3] 为什么要进行傅立叶变换。https://ibillxia.github.io/blog/2013/04/04/why-do-Fourier-transformation/</p>
  ]]></content><author><name>Soulter</name></author><category term="教程" /><category term="音频编码" /><category term="ArchLinux" /><summary type="html"><![CDATA[最近换上了 ArchLinux，体验了众多美观的 TUI 应用。其中我认为最酷炫的当属 ncmpcpp 这个音乐播放器了。]]></summary></entry><entry><title type="html">**勤敏轩 2024**：智潮涌动，硕果盈枝</title><link href="https://ustb-806.github.io/news/2024/12/annual-review/" rel="alternate" type="text/html" title="**勤敏轩 2024**：智潮涌动，硕果盈枝" /><published>2024-12-10T00:00:00+08:00</published><updated>2025-01-21T21:03:46+08:00</updated><id>https://ustb-806.github.io/news/2024/12/annual-review</id><content type="html" xml:base="https://ustb-806.github.io/news/2024/12/annual-review/"><![CDATA[<blockquote>
    <p><strong>勤敏轩 2024</strong>：智潮涌动，硕果盈枝。</p>
  </blockquote>
  <h2 id="勤敏启航创新飞扬">勤敏启航，创新飞扬</h2>
  <p>在充满挑战与机遇的 2024 年，勤敏轩学生创新实验室（简称 806 实验室）秉持着对技术的执着追求和创新的无限热情，走过了充实而辉煌的一年。806 实验室汇聚了众多在校本科生，他们共同致力于计算机专业学科竞赛以及创新创业竞赛的深耕细作。</p>
  <p>实验室下设系统部、人工智能部、游戏部和开发部四个部门，每个部门都承载着不同的使命与梦想。在秋季，我们进行了大规模的招新活动，为实验室注入了新的活力。同时，实验室积极维护自己的官方网站 <a href="https://ustb-806.github.io">https://ustb-806.github.io</a>，为成员们提供了一个展示与交流的平台。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/static/806_2.jpg" alt="alt" />
    勤敏轩实验室</p>
  <h2 id="群英荟萃成就斐然">群英荟萃，成就斐然</h2>
  <h3 id="系统部系统耕耘荣耀绽放">系统部：系统耕耘，荣耀绽放</h3>
  <p>系统部专注于计算机系统能力的培养，在过去的一年里，系统部成员在各类高水平系统能力竞赛中屡获佳绩：</p>
  <ul>
    <li>
      <p>刁明轩同学获得“第八届全国大学生计算机系统能力培养大赛（龙芯杯）”个人赛全国三等奖；</p>
    </li>
    <li>
      <p>丁正枫、王雨辰等同学则荣获“龙芯杯”团体赛全国二等奖；</p>
    </li>
    <li>
      <p>陈宽宽、王诺贤同学在“第四届全国大学生计算机系统能力大赛（操作系统设计赛）内核实现赛道（基于 RISCV 硬件）”中获得了全国二等奖。</p>
    </li>
  </ul>
  <p>这些荣誉的取得，充分展现了系统部成员扎实的专业技能和团队协作精神。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/02.jpg" alt="alt" />
    “龙芯杯”颁奖典礼，刁明轩（左五）</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/03.jpg" alt="alt" />
    “龙芯杯”团队赛复赛现场</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-os-competition/2.jpg" alt="alt" />
    操作系统设计赛</p>
  <h3 id="人工智能部ai-探索智慧引领">人工智能部：AI 探索，智慧引领</h3>
  <p>人工智能部致力于打造优质的 AI 技术学习和开发社群。</p>
  <p>部内成员不仅深入学习了深度学习、CNN、RNN、transformer 等传统模型，还积极参与各类算法竞赛，如计算机设计大赛等，取得了市级二、三等奖的优异成绩。</p>
  <p>祁珏瑜、王苏晴等多名成员还在本校、中科院课题组参与项目实习，发表论文，展现了实验室在 AI 领域的深厚底蕴。</p>
  <h3 id="开发部开发实践创新无限">开发部：开发实践，创新无限</h3>
  <p>开发部涉猎 Android、iOS 客户端、前后端开发、嵌入式开发、AIGC 等应用层领域。</p>
  <p>在过去的一年里，开发部成员在 github 上开源了多个项目，如廖玮珑的 <a href="https://github.com/Soulter/AstrBot">AstrBot</a>、<a href="https://github.com/Soulter/hugging-chat-api">hugging-chat-api</a> 等，获得了广泛好评。同时，他们还开发了 WordEase 英语学习软件，为学校和开源社区做出了宝贵贡献。</p>
  <p>此外，祁珏瑜、崔永亮等成员还开发了 stable-diffusion 插件，进一步丰富了实验室的技术储备。</p>
  <h3 id="游戏部游戏创想乐趣无限">游戏部：游戏创想，乐趣无限</h3>
  <p>游戏部是实验室中充满活力和创意的部门。他们专注于游戏开发与设计，旨在培养成员的游戏制作能力和团队合作精神。</p>
  <p>在过去的一年里，游戏部成员不仅参加了计算机设计大赛并荣获国家三等奖的成绩，还积极实习并担任 Unity 开发的岗位。</p>
  <p>未来，他们计划以月为单位稳定产出游戏作品，并参加各类线上或线下 gamejam 比赛，为实验室的游戏事业贡献力量。</p>
  <h2 id="荣誉满载成果斐然">荣誉满载，成果斐然</h2>
  <p>在全体成员的共同努力下，806 实验室在 2024 年取得了丰硕的成果。实验室一共获得 <strong>国奖 18 项、省（市）奖 19 项、校奖 2 项、软著 2 项以及论文 2 篇</strong>。这些荣誉的取得不仅是对实验室成员努力的肯定，更是对实验室整体实力的彰显。</p>
  <table>
    <thead>
      <tr>
        <th>奖项名称</th>
        <th>获奖者</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>CCPC 中国大学生程序设计竞赛（区域赛）铜奖</td>
        <td>王诺贤</td>
      </tr>
      <tr>
        <td>ICPC 国际大学生程序设计竞赛（区域赛）铜奖</td>
        <td>王诺贤</td>
      </tr>
      <tr>
        <td>ICPC 国际大学生程序设计竞赛（区域赛）铜奖</td>
        <td>陈宽宽</td>
      </tr>
      <tr>
        <td>操作系统设计赛全国二等奖</td>
        <td>陈宽宽、王诺贤</td>
      </tr>
      <tr>
        <td>龙芯杯团体赛全国二等奖</td>
        <td>王雨辰、丁正枫</td>
      </tr>
      <tr>
        <td>龙芯杯个人赛全国三等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>数据库管理系统设计赛优胜奖</td>
        <td>廖玮珑、王诺贤</td>
      </tr>
      <tr>
        <td>蓝桥杯程序设计大赛 C/C++ A 组国家三等奖</td>
        <td>王诺贤</td>
      </tr>
      <tr>
        <td>网络技术挑战赛三等奖</td>
        <td>唐学彬</td>
      </tr>
      <tr>
        <td>全国大学生计算机博弈大赛冠军</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>全国大学生计算机博弈大赛一等奖</td>
        <td>丁正枫</td>
      </tr>
      <tr>
        <td>全国大学生计算机博弈大赛二等奖</td>
        <td>廖玮珑</td>
      </tr>
      <tr>
        <td>“大唐杯”全国大学生新一代信息通信技术大赛国家二等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛国家二等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛国家三等奖</td>
        <td>刁明轩、张溪延、黄昊、韩连伟</td>
      </tr>
      <tr>
        <td>挑战杯揭榜挂帅“虚拟环境中核工程设备运动属性转换与交互技术研究”全国二等奖</td>
        <td>黄昊</td>
      </tr>
      <tr>
        <td>挑战杯全国二等奖</td>
        <td>陈宽宽</td>
      </tr>
      <tr>
        <td>全国青年科普创新实验大赛二等奖</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>计算机系统能力大赛 OceanBase 数据库赛道北京市第一名</td>
        <td>王诺贤、廖玮珑</td>
      </tr>
      <tr>
        <td>计算机系统能力大赛 OceanBase 数据库赛道北京市第三名</td>
        <td>陈宽宽、刁明轩</td>
      </tr>
      <tr>
        <td>蓝桥杯程序设计大赛 C/C++ A 组省级二等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>蓝桥杯程序设计大赛 Python 组省级二等奖</td>
        <td>廖玮珑</td>
      </tr>
      <tr>
        <td>大学生数学竞赛省级一等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>集成电路设计大赛北京市一等奖</td>
        <td>丁正枫</td>
      </tr>
      <tr>
        <td>集成电路设计大赛北京市一等奖</td>
        <td>王雨辰</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛北京市二等奖</td>
        <td>李睿琦</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛北京市三等奖</td>
        <td>朱博林</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛北京市三等奖</td>
        <td>崔永亮、张灿、祁珏瑜、陈铎友</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛北京市三等奖</td>
        <td>周奔成</td>
      </tr>
      <tr>
        <td>华北五省计算机大赛省级三等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>机器人先进视觉赛二等奖</td>
        <td>王诺贤</td>
      </tr>
      <tr>
        <td>全国大学生数学建模国赛北京市二等奖</td>
        <td>刘彦甫</td>
      </tr>
      <tr>
        <td>全国大学生数学建模大赛北京市二等奖</td>
        <td>吴祥楠</td>
      </tr>
      <tr>
        <td>互联网 + 北京市级三等奖</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>京彩大创“百强创业团队”</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>智能汽车竞赛二等奖</td>
        <td>丁正枫</td>
      </tr>
      <tr>
        <td>大学生创新创业大赛二等奖</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>全国大学生电子设计大赛北京市二等奖</td>
        <td>吴祥楠</td>
      </tr>
      <tr>
        <td>LoongArch32R 自主指令集下单周期处理器教学设计与应用</td>
        <td>崔晓龙，王雨辰，张磊，刘欣，林耀虎</td>
      </tr>
      <tr>
        <td>Fast Adaptation Mechanism for Intelligent Routing in Dynamic Networks Based on Transfer Learning</td>
        <td>Xiaolong Cui, Yuchen Wang, Xinyi Xu, Wei Huangfu, Jiahao Huo</td>
      </tr>
      <tr>
        <td>Intelligent art factory: achieving creative automation through parallel art agents</td>
        <td>Chao GUO1, Xingyuan DAI1, Weilong LIAO2, Jueyu QI2, Yue LU3, Qinghua NI4, Lin WANG5, Fei-Yue WANG1</td>
      </tr>
      <tr>
        <td>材料基因智能计算集成系统软著</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>心血管病智能辅诊系统</td>
        <td>刁明轩</td>
      </tr>
    </tbody>
  </table>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-12-10-annual-review/competition1.jpg" alt="alt" />
    证书展柜 1</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-12-10-annual-review/competition2.jpg" alt="alt" />
    证书展柜 2</p>
  <h2 id="硕果累累保研名校">硕果累累，保研名校</h2>
  <p>值得一提的是，806 实验室的大四学生在学业上也取得了令人瞩目的成绩，<strong>大四同学全部保研</strong>。他们凭借扎实的专业技能和出色的综合素质，成功保研至 <strong>北大、南大、北航、国科大、北科、北邮</strong> 等顶尖院校。这一成绩的取得不仅为实验室增添了光彩，更为成员们的未来发展奠定了坚实的基础。</p>
  <h2 id="智领未来续写辉煌">智领未来，续写辉煌</h2>
  <p>展望未来，806 实验室将继续秉承“勤于思，敏于行”的实验室精神，不断探索新技术、新领域，为培养更多优秀的计算机人才贡献力量。我们坚信，在全体成员的共同努力下，806 实验室必将迎来更加辉煌的明天！</p>
  ]]></content><author><name>cxl</name></author><category term="总结" /><category term="年终总结" /><summary type="html"><![CDATA[勤敏轩 2024：智潮涌动，硕果盈枝。]]></summary></entry><entry><title type="html">配置校园网 IPv6 免流</title><link href="https://ustb-806.github.io/blogs/2024/11/ipv6/" rel="alternate" type="text/html" title="配置校园网 IPv6 免流" /><published>2024-11-21T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/ipv6</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/ipv6/"><![CDATA[<p>本文介绍如何在校园网环境内利用教育网 IPv6 进行免流。</p>
  <h2 id="前提">前提</h2>
  <p>校园网免流基于 IPv6 流量不计费，所以要先确定自己使用的无线网/有线网是否支持 IPv6。</p>
  <h2 id="原理">原理</h2>
  <p>校园网同时支持 IPv4 和 IPv6，但是使用 IPV6 并不计费，因此本地通过 IPv6 协议向服务器发送请求，服务器获取到网络资源后再通过 IPv6 将数据发送到本地，就相当于全程使用 IPv6 与互联网进行数据交互。</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629155642916.png" alt="image-20240629155642916" /></p>
  <h2 id="租服务器">租服务器</h2>
  <p>首先我们要租一台代替我们在互联网上下载资源的服务器，或者准确一些，「VPS」。</p>
  <blockquote>
    <p>虚拟专用服务器（Virtual Private Server，简称 VPS）技术，是将一台服务器分割成多个虚拟专享服务器的优质服务。实现 VPS 的技术分为容器技术，和虚拟化技术。在容器或虚拟机中，每个 VPS 都可选配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。——百度百科</p>
  </blockquote>
  <p>那么该租用一个什么样的 VPS 以及在哪里租比较合适呢？</p>
  <p>首先，为了能够保证网络的流畅，我们要证低延迟和高带宽，此外，我们平时也需要科学上网，但能够找到的机场要么贵要么慢，不妨我们直接搞一个既能科学上网又能免流的 VPS。那么我认为 VPS 的位置最合适的就是香港，不仅能访问到大多数外网的资源又能保证不会在使用免流的时候访问不了国内一些网站。</p>
  <p>那么接下来就是 VPS 租用平台的选取，首先排除阿里云等平台，不仅贵而且带宽仅能给到 30Mb/s。在寻找了一段时间之后，我找到了 <a href="https://churros.cloud/index.php">Churros</a> 这个平台，在这可以租到带宽最多为 625Mb/s。</p>
  <p>注册好账号之后，订购新服务：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163011540.png" alt="image-20240629163011540" /></p>
  <p>选择第一个：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163126172.png" alt="image-20240629163126172" /></p>
  <p>进入之后选择详细的服务：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163244014.png" alt="image-20240629163244014" /></p>
  <p>其中 CPU 一核，RAM 1G，存储 10G 就够用。带宽 1Gbps 就是上限 125Mb/s。流量根据自己需求选择，记得一定要有一个 IPv6 地址，否则无法免流。下面的系统可以根据自己的偏好选择，这里以 Ubuntu20.04 LTS 为例。</p>
  <p><strong>记得设定一个自己记得住的 root 密码。</strong></p>
  <p>VPS 设定需要几分钟，设定完成之后在终端中输入：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>ssh root@&lt;你的IPv4地址&gt;
</code></pre>
    </div>
  </div>
  <p>弹出 <code class="language-plaintext highlighter-rouge">Are you sure you want to continue connecting (yes/no/[fingerprint])? </code> 输入 <code class="language-plaintext highlighter-rouge">yes</code>，之后输入自己的密码。</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629170451589.png" alt="image-20240629170451589" /></p>
  <p>成功进入 VPS。</p>
  <h2 id="vps-设定">VPS 设定</h2>
  <p>首先，更新 Ubuntu。终端输入：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>curl
<span class="nb">sudo </span>apt <span class="nb">install </span>socat
<span class="nb">sudo </span>apt <span class="nb">install </span>ufw
</code></pre>
    </div>
  </div>
  <h3 id="安装-x-ui">安装 X-UI</h3>
  <p>终端输入：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>bash &lt;<span class="o">(</span>curl <span class="nt">-Ls</span> https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh<span class="o">)</span>
</code></pre>
    </div>
  </div>
  <p>依次设置账号密码和端口：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629171501501.png" alt="image-20240629171501501" /></p>
  <p>这里我自定义了端口为 <code class="language-plaintext highlighter-rouge">54321</code>，实际上任何端口都可以，自己能记住即可，不必完全相同。</p>
  <h3 id="开放-ufw-防火墙端口">开放 ufw 防火墙端口</h3>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>ufw status   <span class="c"># 查看本地端口开启情况</span>
<span class="nb">sudo </span>ufw <span class="nb">enable</span>   <span class="c"># 开启防火墙，允许访问特定端口</span>
<span class="nb">sudo </span>ufw allow 20
<span class="nb">sudo </span>ufw allow 21
<span class="nb">sudo </span>ufw allow 22
<span class="nb">sudo </span>ufw allow 54321/tcp  <span class="c"># 给 X-UI 面板开放端口</span>
<span class="nb">sudo </span>ufw allow 12345/tcp  <span class="c"># 给后续的 v2ray 开放端口</span>
                          <span class="c"># 如果多人使用根据自己需求再开启几个</span>
<span class="nb">sudo </span>ufw status  <span class="c"># 重新检查端口开放情况</span>
</code></pre>
    </div>
  </div>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629204716087.png" alt="image-20240629204716087" /></p>
  <h3 id="开启-bbr-加速">开启 BBR 加速</h3>
  <p>新的 TCP 拥塞控制算法 BBR (Bottleneck Bandwidth and RTT) 可以让服务器的带宽尽量跑满，并且尽量不要有排队的情况，让网络服务更佳稳定和高效。</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">echo </span>net.core.default_qdisc<span class="o">=</span>fq <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo </span>net.ipv4.tcp_congestion_control<span class="o">=</span>bbr <span class="o">&gt;&gt;</span> /etc/sysctl.conf   <span class="c"># 修改系统变量</span>
sysctl <span class="nt">-p</span>   <span class="c"># 保存</span>
</code></pre>
    </div>
  </div>
  <p>接下来检查是否开启成功。</p>
  <p>分别输入：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>sysctl net.ipv4.tcp_available_congestion_control
lsmod | <span class="nb">grep </span>bbr
</code></pre>
    </div>
  </div>
  <p>如果第一个输出：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>sysctl net.ipv4.tcp_available_congestion_control
net.ipv4.tcp_available_congestion_control <span class="o">=</span> bbr cubic reno
</code></pre>
    </div>
  </div>
  <p>第二个有输出结果（如果失败不会有输出结果）就说明 BBR 开启成功了。</p>
  <h3 id="配置-x-ui">配置 X-UI</h3>
  <p>在浏览器中输入 <code class="language-plaintext highlighter-rouge">&lt;IPv4地址&gt;:&lt;端口号&gt;</code></p>
  <p>如 <code class="language-plaintext highlighter-rouge">103.229.54.***:54321</code> 进行登录</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629190947466.png" alt="image-20240629190947466" /></p>
  <p>在入站列表中配置：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629191636631.png" alt="image-20240629191636631" /></p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629191629249.png" alt="image-20240629191629249" /></p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192247486.png" alt="image-20240629192247486" /></p>
  <p>在操作中点击「二维码」，然后复制：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192346320.png" alt="image-20240629192346320" /></p>
  <h2 id="配置客户端">配置客户端</h2>
  <p>VPS 的配置已经完成，接下来就是要在电脑上使用。</p>
  <h3 id="v2ray-配置">V2ray 配置</h3>
  <p>V2ray 下载：<a href="https://github.com/2dust/v2rayN/releases/download/4.26/v2rayN-Core.zip">下载链接</a>。</p>
  <p>下载后解压，双击「v2rayN」运行。</p>
  <p>在 V2ray 中点击「服务器」，「从剪贴板导入批量 url」</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192535573.png" alt="image-20240629192535573" /></p>
  <p>导入成功如下：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192723613.png" alt="image-20240629192723613" /></p>
  <p>双击，进入编辑，将 IPv4 地址替换为自己的 IPv6 地址：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192853962.png" alt="image-20240629192853962" /></p>
  <p>如下：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193011319.png" alt="image-20240629193011319" /></p>
  <p>点击确定进行保存。</p>
  <p>在任务栏右侧找到 V2ray 的图标，在「服务器」中选择自己的服务器，「系统代理」中选择「自动配置系统代理」，「路由」中选择「全局」。</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193446792.png" alt="image-20240629193446792" /></p>
  <p>在任务管理器中查看网络使用情况，如果全都是 V2ray 用的就代表配置成功了。可以肆意上网了。</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193435397.png" alt="image-20240629193435397" /></p>
  <h2 id="全文完">全文完</h2>
  <blockquote>
    <p>原文链接：<a href="https://fridemn.best/archives/xiao-yuan-wang-mian-liu">https://fridemn.best/archives/xiao-yuan-wang-mian-liu</a></p>
  </blockquote>
  ]]></content><author><name>Fridemn</name></author><category term="教程" /><category term="校园网" /><category term="IPv6" /><summary type="html"><![CDATA[本文介绍如何在校园网环境内利用教育网 IPv6 进行免流。]]></summary></entry><entry><title type="html">如何在 Linux 上部署一个 MC 纯净/整合包服务器</title><link href="https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux/" rel="alternate" type="text/html" title="如何在 Linux 上部署一个 MC 纯净/整合包服务器" /><published>2024-11-20T00:00:00+08:00</published><updated>2025-01-21T21:03:46+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux/"><![CDATA[<blockquote>
    <p>作为 806 系统部的一员，能够在 Linux 服务器上部署一个 MC 服务端是所有人必须要会的技能。——系统部传统</p>
  </blockquote>
  <p>要想和好基友们开黑 MC，一般会采用单人游戏 + 对局域网开放的方式。但是这样有一个弊端：每次游戏的时候都需要主机在线，这对于随时随地都可能想上线种田的大四老登来说是不可容忍的，而 806 正好又不缺服务器，所以在服务器上部署一个 MC 服务端是更合适的方式。</p>
  <p>本文的环境是：</p>
  <ul>
    <li>Ubuntu 24.04 LTS</li>
    <li><a href="https://www.mcmod.cn/modpack/273.html">冬季救援整合包</a>（1.16.5 Forge）</li>
  </ul>
  <p>一些背景知识：</p>
  <ul>
    <li>连接服务器使用 SSH，这里推荐一个很好用的 SSH 客户端 <a href="https://mobaxterm.mobatek.net/">MobaXTerm</a>，其能直接通过自带的 sftp 工具传输文件。</li>
    <li>在服务器上下载文件可以使用 <code class="language-plaintext highlighter-rouge">wget</code>，复制想要下载的文件的链接，直接在终端输入 <code class="language-plaintext highlighter-rouge">wget &lt;下载链接&gt;</code> 回车即可。</li>
    <li>启动游戏推荐使用第三方客户端，这里推荐 <a href="https://afdian.com/p/0164034c016c11ebafcb52540025c377">PCL</a> 和 <a href="https://hmcl.huangyuhui.net/">HMCL</a>，尽量不要用官方启动器，功能贫乏。</li>
  </ul>
  <h2 id="配置-java-环境">配置 Java 环境</h2>
  <p>MC 是用 Java 写的，所以配置 Java 环境也很合理。</p>
  <p>安装 Java 运行环境之前，首先需要知道想要运行的 MC 版本对应的 Java 版本是多少，这里搬运 <a href="https://zh.minecraft.wiki/w/Tutorial:%E6%9B%B4%E6%96%B0Java?variant=zh-cn">MC 官方 Wiki</a> 里关于 Java 版本的说明：</p>
  <table>
    <thead>
      <tr>
        <th>Minecraft 开发版本</th>
        <th>Minecraft 正式版本</th>
        <th>最低要求 Java 版本</th>
        <th>官启绑定 Java 版本</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/24w14a">24w14a</a>及以上</td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.20.5">1.20.5</a>及以上</td>
        <td>Java 21</td>
        <td>21.0.3</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/22w18a">22w18a</a>至<a href="https://zh.minecraft.wiki/w/24w13a">24w13a</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.19">1.19</a>至<a href="https://zh.minecraft.wiki/w/Java版1.20.4">1.20.4</a></td>
        <td>Java 17</td>
        <td>17.0.8</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.18-pre2">1.18-pre2</a>至<a href="https://zh.minecraft.wiki/w/22w17a">22w17a</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.18">1.18</a>至<a href="https://zh.minecraft.wiki/w/Java版1.18.2">1.18.2</a></td>
        <td>Java 17</td>
        <td>17.0.1</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/21w19a">21w19a</a>至<a href="https://zh.minecraft.wiki/w/Java版1.18-pre1">1.18-pre1</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.17">1.17</a>至<a href="https://zh.minecraft.wiki/w/Java版1.17.1">1.17.1</a></td>
        <td>Java 16</td>
        <td>16.0.1</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/21w18a">21w18a</a>及以下</td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.16.5">1.16.5</a>及以下</td>
        <td>Java 8</td>
        <td>1.8.0_51</td>
      </tr>
    </tbody>
  </table>
  <p>由于我需要运行的版本是 1.16.5，因此这里需要安装 Java 8。</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>openjdk-8-jdk
</code></pre>
    </div>
  </div>
  <p>对于其他的 Java 版本，一般来说将上面指令中的 <code class="language-plaintext highlighter-rouge">8</code> 替换成对应的版本号就可以了。</p>
  <p>安装完成后可以使用 <code class="language-plaintext highlighter-rouge">java --version</code> 来查看版本是否正确。</p>
  <p>如果服务器同时安装了多个版本的 Java，可以使用下面的指令来切换默认的 Java 版本：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>update-alternatives <span class="nt">--config</span> java
</code></pre>
    </div>
  </div>
  <h2 id="配置服务端">配置服务端</h2>
  <p>对于原版、Forge 和 Fabric，初始化服务端的方式各不相同。</p>
  <p>国内的 MCSL 维护了一套服务端文件的镜像（<a href="https://sync.mcsl.com.cn/">这里</a>），后文讲到的文件可以先在这里尝试下载。</p>
  <h3 id="原版vanilla">原版（Vanilla）</h3>
  <p>MC 原版的服务端文件可以直接在 Minecraft 官网上下载。直接 Bing/Google 搜索 <code class="language-plaintext highlighter-rouge">minecraft server &lt;版本号&gt; 下载</code>，找到官方网站对应的下载链接即可。下载下来的服务端一般是一个名为 <code class="language-plaintext highlighter-rouge">server.jar</code>的 jar 文件。</p>
  <p>需要注意两点：</p>
  <ul>
    <li>不要用百度，百度只会把你导航到网易（MC 的国内代理，但是依托**）。</li>
    <li>进入官网后，如果你没有挂梯子的话，那么同样会弹窗让你跳转到网易，注意点击下方的 <code class="language-plaintext highlighter-rouge">Stay on Minecraft.net</code> 留在国际版官网。</li>
  </ul>
  <p>当然，也可以使用上面提到的 <a href="https://sync.mcsl.com.cn/core/Vanilla">MCSL 镜像源</a>下载。</p>
  <p>接下来找到一个合适的目录，初始化服务端：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> server.jar nogui
</code></pre>
    </div>
  </div>
  <p>第一次运行服务端，会创建一个 <code class="language-plaintext highlighter-rouge">eula.txt</code>然后报错退出，这个文件的作用是同意许可。使用 vim 或 nano 或其他方式打开，将里面的 <code class="language-plaintext highlighter-rouge">false</code> 改成 <code class="language-plaintext highlighter-rouge">true</code>，保存退出，重新启动即可。</p>
  <p>等到终端出现 <code class="language-plaintext highlighter-rouge">Done!</code> 等文字的时候，说明服务器已经成功启动，此时已经可以直接开始玩了。不过后面会配置一些优化体验的东西，请继续阅读下文。</p>
  <h3 id="forge">Forge</h3>
  <p>Forge 端可以在 <a href="https://files.minecraftforge.net/net/minecraftforge/forge/">Forge 官网</a>上下载（可能需要挂梯子）。当然，也可以使用上面提到的 <a href="https://sync.mcsl.com.cn/core/Forge">MCSL 镜像源</a>下载。</p>
  <p><strong>注意</strong>：Forge 的小版本之间也会出现不兼容的情况，所以如果是配置整合包的话，一定要下载和整合包的 Forge 版本完全一致的服务端。</p>
  <p>下载下来后会得到一个名为 <code class="language-plaintext highlighter-rouge">forge-&lt;游戏版本&gt;-&lt;Forge版本&gt;-installer.jar</code> 的文件。这里我下载的文件名为 <code class="language-plaintext highlighter-rouge">forge-1.16.5-36.2.34-installer.jar</code>。</p>
  <p>找到一个合适的目录，启动：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> forge-1.16.5-36.2.34-installer.jar <span class="nt">--installServer</span>  <span class="c"># 注意要把文件替换为自己下载的</span>
</code></pre>
    </div>
  </div>
  <p>接下来 Forge Installer 会下载一系列文件，包括服务端原始文件，然后自动进行配置。这个阶段需要保持服务器有良好的网络。该过程有可能需要翻墙。</p>
  <p>配置完成之后，会留下一些文件，其中最重要的是三个（注意替换成自己的版本号）：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">forge-1.16.5-36.2.34.jar</code>：Forge 的主体文件，也是 Forge 端运行的入口；</li>
    <li><code class="language-plaintext highlighter-rouge">libraries</code>：资源文件；</li>
    <li><code class="language-plaintext highlighter-rouge">minecraft_server.1.16.5.jar</code>：Forge 运行的服务端文件。</li>
  </ul>
  <p>接下来就可以启动服务器了：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> forge-1.16.5-36.2.34.jar nogui  <span class="c"># 注意把文件替换为自己的</span>
</code></pre>
    </div>
  </div>
  <p>和原版服务器一样，第一次启动会创建 <code class="language-plaintext highlighter-rouge">eula.txt</code> 文件并报错退出，需要将该文件里面的 <code class="language-plaintext highlighter-rouge">false</code> 修改为 <code class="language-plaintext highlighter-rouge">true</code> 保存退出，重新启动即可。</p>
  <p>重新启动服务器后，服务器会生成一系列游戏文件，包括存档文件夹 <code class="language-plaintext highlighter-rouge">world</code> 和放置 mod 的文件夹 <code class="language-plaintext highlighter-rouge">mods</code>。只需要将想要添加的 mod 放入 <code class="language-plaintext highlighter-rouge">mods</code> 文件夹，重新启动，即可加载 mod。</p>
  <p>不过如果是想配置整合包的话，还需要做接下来的工作。</p>
  <p>整合包一般分为两种发布方法，一种是直接把整个游戏打成压缩包，而另一种是采用配置文件压缩包的形式（压缩包内部有一个 <code class="language-plaintext highlighter-rouge">overrides</code> 文件夹，需要从 PCL 等第三方启动器的 <code class="language-plaintext highlighter-rouge">导入整合包</code> 来进行导入）：</p>
  <ul>
    <li>对于第一种方法，需要将压缩包内的 <code class="language-plaintext highlighter-rouge">mods</code>文件夹和所有的与「配置」相关的文件夹都复制到服务器目录下（包括但不限于 <code class="language-plaintext highlighter-rouge">config</code>、<code class="language-plaintext highlighter-rouge">kubejs</code>、<code class="language-plaintext highlighter-rouge">scripts</code>）。<strong>这一步很重要，如果漏掉了任何一个配置文件都可能会导致整合包运行不正确，所以务必仔细检查。</strong></li>
    <li>而对于第二种方法，首先在本地客户端导入整合包，在本地安装完之后，进入游戏版本根目录，将 <code class="language-plaintext highlighter-rouge">mods</code> 文件夹复制到服务器目录下。然后，将配置文件压缩包里 <code class="language-plaintext highlighter-rouge">overrides</code>文件夹下的所有文件复制到服务器目录下即可。</li>
  </ul>
  <p>完成上述操作后，将刚刚启动生成的 <code class="language-plaintext highlighter-rouge">world</code> 文件夹删除（如果没有就不用管了，这一步是因为整合包可能会对地图生成进行改动，需要将原版生成的地图删除了重新生成），重新启动服务端即可。</p>
  <h3 id="fabric">Fabric</h3>
  <p>Fabric 和 Forge 的安装步骤除了下载文件以外基本上相同。</p>
  <p>相比于 Forge 完全不提供中文安装教程，Fabric 提供了一个非常友好的<a href="https://wiki.fabricmc.net/zh_cn:player:tutorials:install_server">官方中文安装教程</a>，请参考这个教程进行安装，然后跳转到 <a href="#forge">Forge 章节</a>的整合包配置部分。</p>
  <h2 id="更多的配置可选">更多的配置（可选）</h2>
  <p>进行完上述的步骤后，服务器文件夹下大致会有以下文件：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-20-how-to-setup-mc-server-on-linux/1.png" alt="" /></p>
  <p>我配置的是 Forge 整合包服务器，所以文件会多出许多，但大致的内容都差不多，多一些少一些差别不大。</p>
  <p>其中和整合包 mod 配置相关的文件有：<code class="language-plaintext highlighter-rouge">config</code>，<code class="language-plaintext highlighter-rouge">kubejs</code>，<code class="language-plaintext highlighter-rouge">defaultconfigs</code>，<code class="language-plaintext highlighter-rouge">worldshape</code>；</p>
  <p>此时，其实就可以启动服务器开始玩了！但是我们还可以再进一步配置一些东西更方便我们运维。</p>
  <h3 id="screen">Screen</h3>
  <p>启动服务器的时候可以使用 screen、tmux 等工具将其挂在后台，这样就可以切断 SSH 连接而不会导致服务器关闭。接下来简单介绍 screen。</p>
  <p>首先安装 screen：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>screen
</code></pre>
    </div>
  </div>
  <p>可以通过指令 <code class="language-plaintext highlighter-rouge">screen</code> 启动一个新的 screen 会话。可以发现，screen 会话和普通的终端没有什么不同，因为其直接沿用了当前终端的配置。不过，screen 会话可以通过快捷键 <code class="language-plaintext highlighter-rouge">&lt;Ctrl-A&gt; + z</code> 来挂起当前会话，通过指令 <code class="language-plaintext highlighter-rouge">screen -r</code> 来重新连接挂起的会话。</p>
  <p>这样每次使用 screen 启动服务器之后，就可以直接关闭终端，让服务器在后台继续运行，下次需要运维的时候重新连接回来即可。</p>
  <h3 id="serverproperties">server.properties</h3>
  <p><code class="language-plaintext highlighter-rouge">server.properties</code> 文件是 MC 服务器的配置文件。我们可以更改里面的一些内容来实现更好的效果：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">allow-flight</code>：建议改为 <code class="language-plaintext highlighter-rouge">true</code>，因为很多整合包提供了飞行的能力，如果不开启的话会被服务器误认为是在作弊而直接踢出；</li>
    <li><code class="language-plaintext highlighter-rouge">difficulty</code>：服务器的难度，有 <code class="language-plaintext highlighter-rouge">peaceful</code>、<code class="language-plaintext highlighter-rouge">easy</code>、<code class="language-plaintext highlighter-rouge">normal</code>和 <code class="language-plaintext highlighter-rouge">hard</code> 四个选项；</li>
    <li><code class="language-plaintext highlighter-rouge">motd</code>：服务器显示在游戏内的说明文字；</li>
    <li><code class="language-plaintext highlighter-rouge">pvp</code>：玩家之间是否相互可以攻击；</li>
    <li><code class="language-plaintext highlighter-rouge">server-port</code>：服务器的端口，如果一台机子上需要运行多个服务器的话，需要分别设置不同的端口才能运行，否则会冲突。</li>
    <li><code class="language-plaintext highlighter-rouge">online-mode</code>：正版验证，开启了的话需要服务器联网才能加入，好处是能有皮肤。</li>
    <li><code class="language-plaintext highlighter-rouge">view-distance</code>：服务器渲染的视距，依照服务器的性能进行调整，如果卡了就调低一点；</li>
  </ul>
  <h3 id="启动参数">启动参数</h3>
  <p>启动服务器的时候可以在 java 指令后添加一些参数来优化性能，这里我只设置了服务器的内存：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> <span class="nt">-Xmx16G</span> <span class="nt">-Xms16G</span> server.jar nogui
</code></pre>
    </div>
  </div>
  <p>其中：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">-Xmx</code>：设置最大内存；</li>
    <li><code class="language-plaintext highlighter-rouge">-Xms</code>：设置最小内存；</li>
    <li><code class="language-plaintext highlighter-rouge">nogui</code>：以命令行模式启动，必须要添加，否在在命令行里会报错。</li>
  </ul>
  <h3 id="开放防火墙端口">开放防火墙端口</h3>
  <p>由于 Ubuntu 默认开启了防火墙 ufw，所以需要在防火墙开放 MC 服务器默认的端口 <code class="language-plaintext highlighter-rouge">25565</code> 才能链接到服务器。</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>ufw allow 25565  <span class="c"># 开放 25565 端口</span>
</code></pre>
    </div>
  </div>
  <p>如果服务器使用了其他的端口的话，需要改成开放对应的其他端口。</p>
  <h3 id="记分板">记分板</h3>
  <p>你可能在看别的人玩服务器的时候发现，可以在 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 键的玩家列表里看到所有玩家的血量，在显示屏右边有一个榜单显示当前死亡数等……这些都是通过原版的记分板实现的。</p>
  <p>在 MC 服务端的控制台输入以下指令：</p>
  <ul>
    <li>
      <p>启用 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 显示血量：</p>
      <div class="language-text highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code>scoreboard objectives add health health "血量"
scoreboard objectives setdisplay list health
</code></pre>
        </div>
    </div>
    </li>
    <li>
      <p>启用侧边栏死亡计数：</p>
      <div class="language-text highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code>scoreboard objectives add deathCount deathCount "死亡数"
scoreboard objectives setdisplay sidebar deathCount
</code></pre>
        </div>
    </div>
    </li>
  </ul>
  <h2 id="配置-mcdreforged可选">配置 MCDReforged（可选）</h2>
  <p>接下来我们会配置一个非常好用的 MC 服务端管理工具 <a href="https://mcdreforged.com/zh-CN">MCDReforged</a>。这个工具是 TIS 服务器开发的，能够在不修改原版任何东西的基础上，给服务端添加很多很好用的功能，比如：自动备份、自动启停、显示玩家位置等。</p>
  <p>MCDReforged 的安装请参考<a href="https://docs.mcdreforged.com/zh-cn/latest/quick_start/index.html">官方手册</a>。注意，安装方式最好选择 pipx，实测在 Ubuntu 24.04 LTS 下只能使用 pipx 安装方式。</p>
  <p>配置好后，每次启动服务器就是在 MCDReforged 的目录下使用指令 <code class="language-plaintext highlighter-rouge">mcdreforged</code> 启动。</p>
  <p>除了接管 MC 那难用的控制台以外，MCDReforged 最好用的功能就是丰富的插件生态。可以查看<a href="https://mcdreforged.com/zh-CN/plugins">官方插件仓库</a>来查找自己喜欢的插件。这里我列举我每次都会安装的几个插件：</p>
  <ul>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/info">Info</a>：能够获取当前服务器的各种信息，例如 CPU 利用率、内存使用率、存档大小等。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/where2go">Where2go</a>：一个功能强大的位置插件，包含共享坐标点、查询玩家位置等功能。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/prime_backup">Prime Backup</a>：一个强大的 MCDR 备份插件，一套先进的 Minecraft 存档备份解决方案。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/hibernate_r/readme">HibernateR</a>：在服务器没有人的时候让服务器休眠，有人连接时开启。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/simple_op">Simple OP</a>：<code class="language-plaintext highlighter-rouge">!!op</code> 以获取 op, <code class="language-plaintext highlighter-rouge">!!restart</code> 以重启服务器。</li>
  </ul>
  <h2 id="本文完">本文完</h2>
  <p>最后是夹带私货时间！</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-11-20-how-to-setup-mc-server-on-linux/banner.png" alt="" />
    猜猜这些都是谁？（提示：全部都是 806 系统部成员）</p>
  <blockquote>
    <p>原文链接：https://blog.bosswnx.xyz/posts/2024/how-to-setup-mc-server-on-linux/</p>
  </blockquote>
  ]]></content><author><name>Nelson Boss</name></author><category term="教程" /><category term="Minecraft" /><category term="Linux" /><summary type="html"><![CDATA[作为 806 系统部的一员，能够在 Linux 服务器上部署一个 MC 服务端是所有人必须要会的技能。——系统部传统]]></summary></entry><entry><title type="html">OceanBase 2024 比赛资源汇总</title><link href="https://ustb-806.github.io/blogs/2024/11/oceanbase/" rel="alternate" type="text/html" title="OceanBase 2024 比赛资源汇总" /><published>2024-11-12T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/oceanbase</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/oceanbase/"><![CDATA[<p>全国大学生计算机系统能力大赛（OceanBase 数据库大赛）于 2024/10/18 正式开始。下面汇总了比赛的各种资源、赛后总结以供大家参考。</p>
  <h2 id="初赛miniob">初赛（MiniOB）</h2>
  <p>资源信息：</p>
  <ul>
    <li>比赛链接：<a href="https://open.oceanbase.com/train?questionId=600010">MiniOB 训练营</a></li>
    <li><a href="https://open.oceanbase.com/competition/armory">数据库大赛英雄榜</a></li>
    <li><a href="https://oceanbase.github.io/miniob/">MiniOB 辅助开发手册</a></li>
    <li><a href="https://www.oceanbase.com/docs/-developer-quickstart-10000000000627360">MiniOB 官方手册</a></li>
    <li>MiniOB 官方教学视频：
      <ul>
        <li><a href="https://www.oceanbase.com/video/9000654">1-1 数据库系统概述…</a></li>
        <li><a href="https://open.oceanbase.com/activities/4921877?id=4921946">从 0 到 1 数据库内核实战教程</a></li>
      </ul>
    </li>
  </ul>
  <p>实用工具：</p>
  <ul>
    <li>MySQL 语法：<a href="https://www.runoob.com/sql/sql-syntax.html">SQL 语法 - 菜鸟教程</a></li>
    <li>在线运行 MySQL：<a href="https://onecompiler.com/mysql/">MySQL - OneCompiler</a></li>
  </ul>
  <p>赛后总结：</p>
  <table>
    <thead>
      <tr>
        <th>队伍 &amp; GitHub 仓库</th>
        <th>成员</th>
        <th>总结</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="https://github.com/bosswnx/miniob-2024">我真的参加了系统内核赛</a></td>
        <td>王诺贤</td>
        <td><a href="https://zhuanlan.zhihu.com/p/5953505884">OceanBase 2024 初赛 MiniOB 开发记录</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>廖玮珑</td>
        <td><a href="https://blog.soulter.top/posts/2024-oceanbase-database.html">OceanBase 数据库内核实现赛 / 自己实现一个数据库</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>陈渠</td>
        <td><a href="https://blog.virtualfuture.top/posts/miniob/">OceanBase 数据库大赛初赛结束之后</a></td>
      </tr>
      <tr>
        <td><a href="https://github.com/SaZiKK/miniob-2024">我一定要参加编译系统实现赛</a></td>
        <td>陈宽宽</td>
        <td><a href="https://sazikk.github.io/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97-OceanBase%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%83%BD%E5%8A%9B%E5%A4%A7%E8%B5%9B%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/">【开发日志】OceanBase 数据库系统能力大赛开发日志</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>刁明轩</td>
        <td><a href="https://dmx20070206.github.io/2024/11/11/miniob/">miniob 初赛参赛总结</a></td>
      </tr>
    </tbody>
  </table>
  <h2 id="决赛oceanbase">决赛（OceanBase）</h2>
  <p>信息汇总中……</p>
  ]]></content><author><name>USTB-806</name></author><category term="竞赛" /><category term="计算机系统能力大赛" /><category term="OceanBase" /><summary type="html"><![CDATA[全国大学生计算机系统能力大赛（OceanBase 数据库大赛）于 2024/10/18 正式开始。下面汇总了比赛的各种资源、赛后总结以供大家参考。]]></summary></entry><entry><title type="html">806 实验室 2024 届招新面试安排</title><link href="https://ustb-806.github.io/news/2024/10/recruitment-iterview-schedule/" rel="alternate" type="text/html" title="806 实验室 2024 届招新面试安排" /><published>2024-10-22T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/news/2024/10/recruitment-iterview-schedule</id><content type="html" xml:base="https://ustb-806.github.io/news/2024/10/recruitment-iterview-schedule/"><![CDATA[<p>面试地点为「机电楼 806 室」，时间安排如下：</p>
  <table>
    <thead>
      <tr>
        <th>部门</th>
        <th>学号</th>
        <th>日期</th>
        <th>时间</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>系统部</td>
        <td>U202442544</td>
        <td>10/26 Sat.</td>
        <td>19:00</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202341236</td>
        <td> </td>
        <td>19:10</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202241800</td>
        <td> </td>
        <td>19:30</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202442610</td>
        <td> </td>
        <td>19:40</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202341615</td>
        <td> </td>
        <td>19:50</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342599</td>
        <td> </td>
        <td>20:00</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202340562</td>
        <td> </td>
        <td>20:10</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202340533</td>
        <td> </td>
        <td>20:20</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342109</td>
        <td> </td>
        <td>20:30</td>
      </tr>
      <tr>
        <td>人工智能部</td>
        <td>U202342602</td>
        <td> </td>
        <td>20:40</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342494</td>
        <td> </td>
        <td>20:50</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342147</td>
        <td> </td>
        <td>21:00</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202442591</td>
        <td> </td>
        <td>21:10</td>
      </tr>
      <tr>
        <td>开发部</td>
        <td>U202342473</td>
        <td> </td>
        <td>21:20</td>
      </tr>
      <tr>
        <td>人工智能部</td>
        <td>U202241805</td>
        <td>10/27 Sun.</td>
        <td>19:00</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202243298</td>
        <td> </td>
        <td>19:10</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202341609</td>
        <td> </td>
        <td>19:20</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202341621</td>
        <td> </td>
        <td>19:30</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342459</td>
        <td> </td>
        <td>19:40</td>
      </tr>
      <tr>
        <td>开发部</td>
        <td>U202342409</td>
        <td> </td>
        <td>19:50</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342490</td>
        <td> </td>
        <td>20:00</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342623</td>
        <td> </td>
        <td>20:10</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202340683</td>
        <td> </td>
        <td>20:20</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342665</td>
        <td> </td>
        <td>20:30</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202343406</td>
        <td> </td>
        <td>20:40</td>
      </tr>
      <tr>
        <td>游戏部</td>
        <td>U202342449</td>
        <td> </td>
        <td>20:50</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342472</td>
        <td> </td>
        <td>21:00</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342892</td>
        <td> </td>
        <td>21:10</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202340122</td>
        <td> </td>
        <td>21:20</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202442567</td>
        <td> </td>
        <td>21:30</td>
      </tr>
      <tr>
        <td> </td>
        <td>U202342439</td>
        <td> </td>
        <td>21:40</td>
      </tr>
      <tr>
        <td>人工智能部</td>
        <td>U202342615</td>
        <td> </td>
        <td>21:50</td>
      </tr>
    </tbody>
  </table>
  <p><strong>注意：</strong>名单会随各种情况动态更新，请在面试当天再次确认面试时间点。最近更新时间为 2024/10/25 16:00。</p>
  <p>面试时，请携带至少三张打印好的个人简历和电脑（用以展示项目）。</p>
  <p>如有时间冲突需要调整，或有其他任何问题，请在 <strong>10 月 25 日 23:59</strong> 前邮件联系 <a href="mailto:wnx@xs.ustb.edu.cn">wnx@xs.ustb.edu.cn</a>，过期不候，名单锁定。</p>
  ]]></content><author><name>USTB-806</name></author><category term="其他" /><summary type="html"><![CDATA[面试地点为「机电楼 806 室」，时间安排如下：]]></summary></entry><entry><title type="html">806 实验室 2024 届招新</title><link href="https://ustb-806.github.io/news/2024/10/recruitment/" rel="alternate" type="text/html" title="806 实验室 2024 届招新" /><published>2024-10-08T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/news/2024/10/recruitment</id><content type="html" xml:base="https://ustb-806.github.io/news/2024/10/recruitment/"><![CDATA[<p>806 实验室从即日起开始 2024 届招新，共四个部门：系统部、人工智能部、游戏部、开发部。报名截止时间为<strong>北京时间 2024 年 10 月 25 日 23:59</strong>。</p>
  <h2 id="报名方式">报名方式</h2>
  <p>按照以下格式发送邮件到 <a href="/wiki/806/contact/">806 官方邮箱</a>：</p>
  <ul>
    <li>主题：<code class="language-plaintext highlighter-rouge">2024招新-&lt;报名的部门&gt;-&lt;学号&gt;-&lt;姓名&gt;</code>；（报名人工智能部仅需填写<code class="language-plaintext highlighter-rouge">人工智能部</code>）
      <ul>
        <li>举例：<code class="language-plaintext highlighter-rouge">2024招新-系统部-U1234567-张三</code>；</li>
        <li><strong>注意：请严格按照格式填写主题，否则我们可能无法收到邮件</strong>；</li>
      </ul>
    </li>
    <li>正文：若报名人工智能部，请在此告知报名的小组；</li>
    <li>附件：个人简历（必须，<strong>pdf 格式</strong>，内容任意），其他能够证明个人能力的内容（可选）。</li>
  </ul>
  <p>我们会不定期查看邮件。若我们成功收到了你的邮件，并且你通过了简历筛选，我们会回复一封邮件以告知面试地点和时间。</p>
  <p>面试时，请携带至少三张打印好的个人简历和电脑（用以展示项目）。</p>
  <p>若对本次招新有任何疑问，请邮件询问 <a href="mailto:wnx@xs.ustb.edu.cn">wnx@xs.ustb.edu.cn</a>。</p>
  <h2 id="各部门招新介绍">各部门招新介绍</h2>
  <h3 id="系统部">系统部</h3>
  <p>系统部是 806 实验室历史最为悠久的部门，专注于计算机系统能力的培养，鼓励督促成员参加高水平系统能力竞赛，如龙芯杯、系统能力大赛等，部内多届成员均参与竞赛，超过一半人在系统能力大赛中获得国家级奖项。</p>
  <p>系统部的成果丰富，曾多次在操作系统赛、编译系统赛、ICPC 等计算机顶级赛事获国家级奖项，今年还首次在龙芯杯获得国二，为我校实现了从零到一的突破。毕业学长学姐均前往北京大学、北京航空航天大学、南京大学、中科院计算所、中科院软件所等顶级高校深造，或是前往百度、腾讯等大厂工作。</p>
  <p>系统部根据传统 CS 的主要方向，分为 OS 组、CPU 组、编译组、数据库组，每个方向均由相关学长学姐指导，积累了丰富的学习资料和比赛经验，欢迎在对应领域有兴趣、有研究的同学加入。</p>
  <p>我们希望你：</p>
  <ul>
    <li>基础扎实：对 C/C++、Rust 或是 Verilog 语言有扎实的基础；</li>
    <li>目标明确：对于传统 CS 中的领域有强烈的兴趣，希望提升系统能力；</li>
    <li>吃苦耐劳，脚踏实地：参与系统能力大赛需要至少 6 个月的持续投入和努力，牺牲大部分假期时间（寒暑假），且短期没有正反馈；</li>
    <li>自我审视：对于自己的所感兴趣的方向有一定的了解，自己不会在探索中半途而废；</li>
    <li>不卷加权：加权成绩固然重要，但是对于第一名和第二名的固执没有意义。</li>
  </ul>
  <p>拟招 5 人左右。</p>
  <h3 id="人工智能部">人工智能部</h3>
  <p>人工智能部致力于聚集热爱 AI 的同学，打造优质的 AI 技术学习和开发社群，一起探索 AI 算法竞赛，开发构建好玩的 AIGC 应用。</p>
  <p>为了更好的推进和管理人工智能部的学习和项目开发，下设算法组、AIGC 组和网络组。</p>
  <h4 id="算法组">算法组</h4>
  <p>算法组的目标是：</p>
  <ul>
    <li>一起交流和探索 AI 算法竞赛，如 Kaggle 奖金池 $60000 的竞赛；</li>
    <li>一起提升算法设计能力，推荐加入本外校的实习项目组；</li>
    <li>论文产出。</li>
  </ul>
  <p>我们希望你：</p>
  <ul>
    <li>有较好的编程基础和逻辑能力；</li>
    <li>对 AI 算法的探究有浓厚的兴趣；</li>
    <li>每周投入时间进行学习、交流，愿意参加定期的组会汇报。</li>
  </ul>
  <p>加分项：</p>
  <ul>
    <li>熟悉 Python 编程；</li>
    <li>对传统的 CNN，RNN，transformer 模型等有了解；</li>
    <li>有深度学习相关的项目开发经验；</li>
    <li>有输出技术博客的习惯。</li>
  </ul>
  <p>拟招 4 人左右。</p>
  <h4 id="aigc-组">AIGC 组</h4>
  <p>AIGC 组的目标是：</p>
  <ul>
    <li>学习开发和维护 AI 应用的传统项目，并产出和维护工程文档，申请软著等；</li>
    <li>了解最新 AI 行业动态，学习大模型、Stable Diffusion、Midjourney 等成熟的 AIGC 项目的迁移和开发；</li>
    <li>参与一些热门 github 项目的开发和维护。</li>
  </ul>
  <p>我们希望你：</p>
  <ul>
    <li>对 AIGC 应用有了解；</li>
    <li>使用过常见的 AIGC 应用，例如各类生成式模型软件，图片生成、音视频生成等；</li>
    <li>对 AIGC 应用部署和开发有浓厚的兴趣；</li>
    <li>每周投入时间进行学习、交流，愿意参加定期的组会汇报。</li>
  </ul>
  <p>加分项：</p>
  <ul>
    <li>熟悉 Python 编程；</li>
    <li>有 AI 应用插件的开发经验；</li>
    <li>有 AI 应用相关的项目和比赛经验；</li>
  </ul>
  <p>拟招 3 人左右。</p>
  <h4 id="网络组">网络组</h4>
  <p>网络组的目标是：针对新一代网络架构（如软件定义网络 SDN、知识定义网络 KDN 等），通过图神经网络（GNN）、深度强化学习（DRL）、迁移学习（Transfer Learning）等方法，预测网络性能指标、改进网络路由算法、对网络传输进行建模。</p>
  <p>要求：</p>
  <ul>
    <li>大一或大二同学，时间能够保证，能按要求完成实验任务；</li>
    <li>熟练掌握 Python、C++ 编程语言，能够阅读并修改代码；</li>
    <li>有 Linux 基础，完成各种环境搭建；</li>
    <li>对网络仿真有一定了解；</li>
    <li>有一定的英文阅读能力，能阅读全英论文；</li>
    <li>有责任心，愿意参与科研项目，对网络研究方向有极大的兴趣。</li>
  </ul>
  <p>拟招 5 人左右。</p>
  <h3 id="游戏部">游戏部</h3>
  <blockquote>
    <p>本座乃游戏之神，以电子游戏入道成为三界第一强者，无奈遭人暗算被关进昊天塔三万年，为了拿到赤地女子的元神解封我族十万将士，准备假意与她成婚，没想到本座的小尾巴兰花仙子跟过来了，各种拈酸吃醋差点坏我大事，只能想个计策稳住她，来个人类加入 806 游戏组，做个游戏给她玩，共谋本座游戏复兴大业！</p>
  </blockquote>
  <p>你能学到什么：Unity，C#。</p>
  <p>你需要做什么：能认真学习 Unity，能按时参与工作室每周的组会，能每个月<strong>与团队一起从零开始完成一个游戏 DEMO</strong>。</p>
  <p>你能得到什么：与团队一起参与竞赛，获取相关经历、经验，获取一些实习机会。</p>
  <p>我们对你的需求是：有基本的编程能力、学习能力。</p>
  <p>加分项：</p>
  <ul>
    <li>具有游戏开发相关经验，如使用过 Unity，UE，Godot 或其它游戏引擎；</li>
    <li>了解游戏设计，如知悉各类游戏的基本特征、游戏机制及如何实现等；</li>
    <li>具有电子绘画能力，如绘制角色帧动画、立绘，游戏内场景、UI 的能力；</li>
  </ul>
  <p>拟招 5 人左右。</p>
  <h3 id="开发部">开发部</h3>
  <p>806 开发部欢迎对 Android、iOS 客户端、前后端开发、嵌入式开发、AIGC 等应用层领域感兴趣的同学加入。</p>
  <p>我们提供出色和领先的硬件和空间资源。在这里，你将有机会释放你的想象力，设计并实现一个或多个有趣且实用的项目。这些项目可以成为实验室、学校或开源社区的宝贵贡献，并且你还可以将它们用于参加创新和创业竞赛。</p>
  <p>开发部的目标是：</p>
  <ul>
    <li>学习开发和维护传统项目，并产出和维护工程文档，申请软著等；</li>
    <li>参与一些热门 GitHub 项目的开发和维护；</li>
  </ul>
  <p>我们希望你：</p>
  <ul>
    <li>对上述领域任一项或多项感兴趣；</li>
    <li>有 Python/Java/GoLang/JS 或其他语言中的一个或多个的开发经验。</li>
  </ul>
  <p>加分项：</p>
  <ul>
    <li>有开源项目，对开源感兴趣；</li>
    <li>接触过一个或多个常见的前后端框架，如 Gin、Flask、FastAPI、SpringBoot、Vue、React；</li>
    <li>有嵌入式开发经验，如 Arduino、树莓派、ESP32 等；</li>
    <li>有技术博客输出的习惯；</li>
    <li>设计过一个或多个项目。</li>
  </ul>
  <p>拟招 5 人左右。</p>
  ]]></content><author><name>USTB-806</name></author><category term="其他" /><summary type="html"><![CDATA[806 实验室从即日起开始 2024 届招新，共四个部门：系统部、人工智能部、游戏部、开发部。报名截止时间为北京时间 2024 年 10 月 25 日 23:59。]]></summary></entry><entry><title type="html">祝贺刁明轩、丁正枫、王雨辰在“第八届全国大学生计算机系统能力培养大赛（龙芯杯）”取得佳绩</title><link href="https://ustb-806.github.io/news/2024/10/lxb/" rel="alternate" type="text/html" title="祝贺刁明轩、丁正枫、王雨辰在“第八届全国大学生计算机系统能力培养大赛（龙芯杯）”取得佳绩" /><published>2024-10-02T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/news/2024/10/lxb</id><content type="html" xml:base="https://ustb-806.github.io/news/2024/10/lxb/"><![CDATA[<p>全国大学生计算机系统能力培养大赛（龙芯杯）是由系统能力培养研究专家组和系统能力培养示范高校共同发起，以学科竞赛推动专业建设和计算机领域创新人才培养体系改革、培育我国高端芯片及核心系统的技术突破与产业化后备人才为目标，面向高校大学生举办的全国性大赛。</p>
  <p>第八届全国大学生计算机系统能力培养大赛（龙芯杯）分为团体赛和个人赛两项赛事。团队赛共 110 支队伍报名，个人赛共 782 人报名。经过初赛的激烈角逐，全国共有 28 支代表队和 40 位个人进入决赛。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/01.jpg" alt="" />
    决赛合影</p>
  <p>在个人赛方面，刁明轩同学设计了基于 MIPS 指令集的 32 位单发射五级流水线 CPU。初赛中，该作品可以通过三级功能测试和性能测试，时钟频率可以稳定运行在 58MHz。现场决赛阶段，刁明轩同学顺利完成了现场汇编代码的编写，最终获得龙芯杯个人赛三等奖。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/02.jpg" alt="" />
    个人赛颁奖（左五：刁明轩）</p>
  <p>在团队赛方面，北科队伍 tesserae of tantalus（成员：丁正枫、王雨辰、赖烁喆、张卓立）实现了一个六级流水顺序双发射的处理器软核，同时实现了分支预测，指令数据缓存，TLB 等模块，可以顺利启动经典的 bootloader 并完成指定功能。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/03.jpg" alt="" />
    团队赛决赛现场（从左到右：王雨辰、赖烁喆、丁正枫）</p>
  <p>现场决赛阶段，经过团队指令集答题，汇编代码编写，团队答辩等环节的重重考验，最终获得全国二等奖，实现了我校在该项赛事成绩的新突破。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/04.jpg" alt="" />
    团队赛颁奖</p>
  <p>获奖证书：</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/certificate1.jpg" alt="" />
    个人赛三等奖</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/certificate2.jpg" alt="" />
    团队赛二等奖</p>
  ]]></content><author><name>USTB-806</name></author><category term="竞赛" /><category term="系统部" /><category term="龙芯杯" /><category term="计算机系统能力大赛" /><summary type="html"><![CDATA[全国大学生计算机系统能力培养大赛（龙芯杯）是由系统能力培养研究专家组和系统能力培养示范高校共同发起，以学科竞赛推动专业建设和计算机领域创新人才培养体系改革、培育我国高端芯片及核心系统的技术突破与产业化后备人才为目标，面向高校大学生举办的全国性大赛。]]></summary></entry></feed>