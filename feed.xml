<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ustb-806.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ustb-806.github.io/" rel="alternate" type="text/html" /><updated>2025-11-26T14:02:52+08:00</updated><id>https://ustb-806.github.io/feed.xml</id><title type="html">806 @ USTB</title><subtitle>北京科技大学「勤敏轩」学生创新实验室</subtitle><author><name>USTB-806</name></author><entry><title type="html">祝贺！806 成员开发的开源项目 AstrBot 获 GitHub 1.3w+ Star 并引领 Agent 开发新范式</title><link href="https://ustb-806.github.io/news/2025/11/astrbot/" rel="alternate" type="text/html" title="祝贺！806 成员开发的开源项目 AstrBot 获 GitHub 1.3w+ Star 并引领 Agent 开发新范式" /><published>2025-11-26T00:00:00+08:00</published><updated>2025-11-26T12:29:58+08:00</updated><id>https://ustb-806.github.io/news/2025/11/astrbot</id><content type="html" xml:base="https://ustb-806.github.io/news/2025/11/astrbot/"><![CDATA[<p>近日，806 成员开发的开源大模型应用 AstrBot 在开源社区取得重大影响力突破。截至目前，该项目在 GitHub 上已获得超过 13,600 颗 Star，Forks 数突破 1,000，Docker 拉取次数超过 193,000 次，成为了连接大语言模型（LLM）与即时通讯（IM）平台领域的标杆性基础设施。
        <img src="https://blog-s3.806.group/post/2025-11-25-AstrBot/01.png" alt="" /></p>
      <p><strong>项目介绍</strong>
        AstrBot (Agentic IM ChatBot Infrastructure) 是一个功能强大的多平台大模型机器人基础设施。该项目旨在为开发者和研究人员提供一个高可扩展的 Agent 开发框架，支持将 OpenAI、Gemini、DeepSeek 等前沿大模型无缝接入到 QQ、企业微信、Telegram、Discord、飞书、钉钉等主流即时通讯软件中。
        与传统的问答机器人不同，AstrBot 引入了 Agentic（智能体）能力，支持多轮工具调用、内置代码执行沙盒、原生 RAG（检索增强生成）知识库以及多模态交互。这使得机器人不仅能进行对话，更能自主完成复杂的任务流，真正实现了从“聊天”到“办事”的跨越。
        <img src="https://blog-s3.806.group/post/2025-11-25-AstrBot/02.png" alt="" /></p>
      <p><strong>社区影响力与技术贡献</strong>
        自发布以来，AstrBot 凭借其优秀的架构设计和活跃的开源社区，迅速成长为 LLM 应用落地的重要工具。
        • 广泛的生态支持：社区已贡献超过 660+ 个插件，涵盖了从效率工具到娱乐互动的多种场景。
        • 高活跃度：项目 7 日活跃部署实例数超过 7,600+，7 日活跃交互用户数突破 110,000+，证明了其在实际生产环境中的可靠性。
        • 技术兼容性：全面支持 Dify、Coze 等 LLMOps 平台，兼容多种部署方式（Docker, Windows, 宝塔等），极大地降低了 AI 应用的开发与部署门槛。
        Soulter 同学在项目开发过程中，展现了出色的全栈工程能力与开源社区运营能力，为大模型应用在即时通讯场景下的普及做出了重要贡献。
        相关链接
        • 项目主页：https://astrbot.app/
        • 代码仓库：https://github.com/AstrBotDevs/AstrBot
        再次祝贺 Soulter 同学取得的优异成绩！希望实验室全体成员继续秉持开源精神，在人工智能与软件工程领域探索更多可能。</p>
      ]]></content><author><name>USTB-806</name></author><category term="开源项目" /><category term="开发部" /><category term="AstrBot" /><summary type="html"><![CDATA[近日，806 成员开发的开源大模型应用 AstrBot 在开源社区取得重大影响力突破。截至目前，该项目在 GitHub 上已获得超过 13,600 颗 Star，Forks 数突破 1,000，Docker 拉取次数超过 193,000 次，成为了连接大语言模型（LLM）与即时通讯（IM）平台领域的标杆性基础设施。]]></summary></entry><entry><title type="html">**勤敏轩 2025**：智创未来，风华正茂</title><link href="https://ustb-806.github.io/news/2025/11/annual-review/" rel="alternate" type="text/html" title="**勤敏轩 2025**：智创未来，风华正茂" /><published>2025-11-25T00:00:00+08:00</published><updated>2025-11-26T14:01:27+08:00</updated><id>https://ustb-806.github.io/news/2025/11/annual-review</id><content type="html" xml:base="https://ustb-806.github.io/news/2025/11/annual-review/"><![CDATA[<p>2025 年，勤敏轩学生创新实验室（806 实验室）在技术探索与创新实践的道路上步履不停，以坚实的成果与蓬勃的朝气，书写了一页页属于集体的荣耀篇章。实验室继续以学科竞赛与创新创业为核心，依托系统部、人工智能部、开发部、网络组等多部门协同发力，在国家级竞赛、学术研究、技术转化与人才培养等方面取得全面突破。</p>
    <h2 id="一竞赛赛场锋芒尽显">一、竞赛赛场，锋芒尽显</h2>
    <p>2025 年，实验室成员在国内外多项高水平赛事中屡创佳绩，共获国家级奖项 17 项、省部级奖项 29 项，覆盖人工智能、程序设计、系统设计、数学建模、创新创业等多个领域，展现出全面的技术实力与创新活力。
      • 人工智能部在“挑战杯”青聚 AI 专项赛中包揽特等、一等、二等奖，张灿同学荣获美国大学生数学建模大赛 M 奖，陈铎友、张灿等在中国大学生计算机设计大赛、中国国际大学生创新大赛中屡获省部级荣誉；
      • 系统部在计算机系统能力大赛、集成电路设计赛、OceanBase 数据库大赛中表现突出，刘畅、代宏利、吴函霖等同学斩获多项国家级与省部级奖项；
      • 开发部在华北五省计算机应用大赛、计算机设计大赛、挑战杯社会治理专项赛中均有亮眼表现，黄钰腾、方正、唐志星等同学协作攻坚，屡获省市级奖励；
      • 网络组唐学彬同学在第十届网络技术挑战赛总决赛中荣获国家级三等奖，并在多项通信与工程类赛事中稳扎稳打，积累实战经验。</p>
    <h2 id="二学术科研立足前沿">二、学术科研，立足前沿</h2>
    <p>在学术研究方面，实验室成员持续深耕，成果丰硕。本年度共发表论文 3 篇，其中 A 类国际会议论文 2 篇（ACMMM 2025、CVPR 2025），《工程科学学报》论文 1 篇，研究方向涵盖稀疏视图 CT 重建、小样本脑血管分割、视觉 - 语言模型空间感知等前沿领域。此外，还有 2 篇论文在投，展现出持续的科研生命力。在技术转化方面，申请发明专利“一种 QoS 路由优化方法、系统、计算机及可读存储介质”，体现了实验室从理论到实践的闭环能力。</p>
    <h2 id="三保研捷报星光璀璨">三、保研捷报，星光璀璨</h2>
    <p>在学业发展方面，806 实验室 2025 届毕业生再传喜讯。同学们凭借扎实的专业基础、丰富的项目经历与竞赛成果，成功保研至多所国内顶尖高校，其中包括：
      • 清华大学（1 人）
      • 中国科学院大学（5 人）
      • 北京科技大学（2 人）
      • 北京邮电大学（1 人）
      这一成绩不仅是对同学们个人能力的认可，也是实验室人才培养机制成效的有力证明。</p>
    <h2 id="四团队协作共筑生态">四、团队协作，共筑生态</h2>
    <p>806 实验室始终注重团队文化与技术生态的构建。各部门之间在项目开发、竞赛备战、论文写作中紧密协作，形成了“以老带新、跨组融合”的良好机制。官方网站（ustb-806.github.io）持续维护，成为对外展示与内部交流的重要窗口。</p>
    <h2 id="五展望未来步履不停">五、展望未来，步履不停</h2>
    <p>回首 2025，806 实验室以实干为笔，以创新为墨，写下了充满收获的一年；展望未来，实验室将继续秉持“勤于思，敏于行”的精神，在人工智能、系统架构、网络技术、交叉学科等领域持续深耕，为每一位成员搭建成长与突破的舞台。
      我们相信，在所有人的共同努力下，806 实验室必将——智创未来，风华正茂！</p>
    ]]></content><author><name>cxl</name></author><category term="总结" /><category term="年终总结" /><summary type="html"><![CDATA[2025 年，勤敏轩学生创新实验室（806 实验室）在技术探索与创新实践的道路上步履不停，以坚实的成果与蓬勃的朝气，书写了一页页属于集体的荣耀篇章。实验室继续以学科竞赛与创新创业为核心，依托系统部、人工智能部、开发部、网络组等多部门协同发力，在国家级竞赛、学术研究、技术转化与人才培养等方面取得全面突破。]]></summary></entry><entry><title type="html">祝贺！陈铎友在顶级多媒体会议 ACMMM2025 发表论文并进行现场报告</title><link href="https://ustb-806.github.io/news/2025/11/ACMMM/" rel="alternate" type="text/html" title="祝贺！陈铎友在顶级多媒体会议 ACMMM2025 发表论文并进行现场报告" /><published>2025-11-03T00:00:00+08:00</published><updated>2025-11-03T20:21:45+08:00</updated><id>https://ustb-806.github.io/news/2025/11/ACMMM</id><content type="html" xml:base="https://ustb-806.github.io/news/2025/11/ACMMM/"><![CDATA[<p>近日，陈铎友（第一作者）及其合作者（其中张灿，王周同为 806 人工智能部成员）撰写的学术论文《Latent Space Consistency For Sparse-View CT Reconstruction》（稀疏视角 CT 重建中的潜在空间一致性）已于第 33 届国际顶级多媒体会议 <strong>ACM Multimedia 2025</strong>上成功发表，并在会议期间进行了现场报告。这一成果的取得，标志着陈铎友在三维医学图像重建研究领域取得了重要突破。论文首页如附图所示。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2025-11-03-ACMMM/03.png" alt="" />
    论文首页 (全文详见 https://doi.org/10.1145/3746027.3755572)</p>
  <p>ACMMM（ACM International Conference on Multimedia）是计算机科学领域最重要、最负盛名的多媒体旗舰会议，今年迎来了第 33 届盛会。该会议由国际计算机协会（ACM）主办，属于中国计算机学会（CCF）推荐的 A 类国际学术会议，在全球多媒体、计算机视觉、人机交互等研究领域具有极高的学术地位和影响力。ACMMM 2025 已于 2025 年 10 月 27 日 -10 月 31 日 在爱尔兰都柏林的<strong>皇家都柏林会议中心（Royal Dublin Convention Centre）</strong>成功举办。本次大会致力于整合和交流跨模态信息，重点关注人工智能、3D 与元宇宙、医疗保健、教育和娱乐等领域的创新应用，吸引了来自世界各地的顶尖学者、研究人员和行业精英，分享最新的研究成果和技术进展。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2025-11-03-ACMMM/02.jpg" alt="" />
    陈铎友在 ACMMM2025 会议现场</p>
  <p>陈铎友的论文聚焦于稀疏视角 CT 重建这一重要的医学影像技术难题。他指出，计算机断层扫描（CT）虽然是临床广泛使用的影像模态，但传统的密集采集方式存在扫描时间长和辐射暴露量大的挑战，而稀疏视角 CT 重建技术旨在利用少量 X 射线投影图像高效准确地恢复三维 CT 图像，从而降低成本和风险。研究团队发现，现有基于扩散模型（如 Latent Diffusion Model, LDM）的重建方法，在处理 2D X 射线投影的潜在表示与 3D CT 图像的潜在表示时，难以有效对齐这两种模态的潜在空间。针对该问题，论文提出了一致性潜在空间扩散模型（Consistent Latent Space Diffusion Model, CLS-DM），并创新性地引入了<strong>跨模态特征对比学习（cross-modal feature contrastive learning）</strong>机制，成功解决了 2D 和 3D 潜在空间的不一致性问题，显著提升了稀疏视角下 CT 图像三维重建的质量和效率。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2025-11-03-ACMMM/01.jpg" alt="" />
    陈铎友在进行现场汇报（爱尔兰都柏林皇家会议中心）</p>
  <p>陈铎友已成功参加了 ACMMM 2025 线下会议，并在国际同行面前展示和解读了其研究成果。现场报告是对研究工作的专业认可，也是与全球多媒体领域专家学者进行深入交流、拓展学术视野的绝佳平台。附图中，我们看到陈铎友同学在会议宣传板前的合影，以及他在会议现场进行报告的精彩瞬间。本次论文的成功发表和现场汇报，是团队在多媒体研究领域的重要一步。</p>
  ]]></content><author><name>USTB-806</name></author><category term="学术会议" /><category term="人工智能部" /><category term="ACMMM" /><summary type="html"><![CDATA[近日，陈铎友（第一作者）及其合作者（其中张灿，王周同为 806 人工智能部成员）撰写的学术论文《Latent Space Consistency For Sparse-View CT Reconstruction》（稀疏视角 CT 重建中的潜在空间一致性）已于第 33 届国际顶级多媒体会议 ACM Multimedia 2025上成功发表，并在会议期间进行了现场报告。这一成果的取得，标志着陈铎友在三维医学图像重建研究领域取得了重要突破。论文首页如附图所示。]]></summary></entry><entry><title type="html">祝贺刁明轩、唐学彬、刘彦甫、刘畅在“2025ASC 世界大学生超级计算机竞赛”取得佳绩</title><link href="https://ustb-806.github.io/news/2025/05/asc/" rel="alternate" type="text/html" title="祝贺刁明轩、唐学彬、刘彦甫、刘畅在“2025ASC 世界大学生超级计算机竞赛”取得佳绩" /><published>2025-05-27T00:00:00+08:00</published><updated>2025-05-27T21:46:01+08:00</updated><id>https://ustb-806.github.io/news/2025/05/asc</id><content type="html" xml:base="https://ustb-806.github.io/news/2025/05/asc/"><![CDATA[<p>ASC 世界大学生超级计算机竞赛（ASC Student Supercomputer Challenge）由中国发起组织，并得到亚洲及欧美相关专家和机构支持，旨在推动国际超算青年人才培养与技术创新，现已成为全球规模最大的大学生超算赛事，累计吸引六大洲上万名学生参与。</p>
  <p>近日，2025ASC 世界大学生超级计算机竞赛（ASC25）顺利结束，本届赛事聚焦”AI for Science”前沿领域，首创性将 AlphaFold3 蛋白质预测（2024 诺贝尔化学奖）与 mRNA 疫苗 RNA 修饰技术（2023 诺贝尔医学奖）转化为核心赛题，构建”计算生物学 - 人工智能 - 超算系统”融合竞技平台。</p>
  <p>在为期两个月的预赛中，我校团队在 4000 瓦功耗约束下自行设计超级计算机系统，完成了 HPL、HPCG 基准测试优化、AlphaFold3 蛋白质结构预测推理加速及 RNA m5C 修饰位点检测等核心任务。来自全球的 300 余支队伍经过激烈角逐，最终，浙江大学、北京大学、清华大学等 25 支队伍脱颖而出获得一等奖。我校 ASC889 队、ASC1172 队、ASC888 队分别以第 28 名、第 31 名、第 78 名的成绩荣获二等奖，与我校代表队同获二等奖的还有来自电子科技大学等高校代表队。</p>
  <p>ASC1172 队刁明轩在 RNA m5C 检测赛题中，完成了从原始测序数据到高置信度 m5C 位点检测的全流程复现与优化。通过整合 Snakemake 工作流，基于 Conda 封装 hisat3n、samtools 等工具链，解决了参考基因组 C→T 索引构建、多步骤并行参数配置等关键问题，成功复现流程并验证初始结果。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2025-05-27-asc/01.jpg" alt="" />
    ASC1172 队伍合照（右一：刁明轩）</p>
  <p>ASC889 队在 AlphaFold3 推理优化上，主要通过软件层面的算法加速技术提升计算效率。通过采用 Flashattention2 优化注意力机制的计算路径，降低显存占用并加速矩阵运算；结合 DPM-Solver 改进扩散过程求解器的数值稳定性，减少迭代次数；同时实现了从 GPU 到 CPU 上的迁移，并启用了持久缓存优化。通过严格的测试和优化流程，最终在保障结构预测精度的前提下压缩了计算耗时。</p>
  <p>对于 m5C 修饰点检测，通过采用并行压缩、精细化线程分配及过滤条件调整，减少 I/O 瓶颈与计算负载。同时采取分治并行合并策略、惰性求值及向量化计算等优化数据读写与内存管理，综合实现性能提升。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2025-05-27-asc/02.jpg" alt="" />
    ASC889 队伍合照（从左至右，中间三位：刘彦甫、唐学彬、刘畅）</p>
  ]]></content><author><name>USTB-806</name></author><category term="竞赛" /><category term="系统部" /><category term="超算" /><summary type="html"><![CDATA[ASC 世界大学生超级计算机竞赛（ASC Student Supercomputer Challenge）由中国发起组织，并得到亚洲及欧美相关专家和机构支持，旨在推动国际超算青年人才培养与技术创新，现已成为全球规模最大的大学生超算赛事，累计吸引六大洲上万名学生参与。]]></summary></entry><entry><title type="html">第四次工业革命｜Cursor 体验报告</title><link href="https://ustb-806.github.io/blogs/2025/01/cursor-experience-review/" rel="alternate" type="text/html" title="第四次工业革命｜Cursor 体验报告" /><published>2025-01-20T00:00:00+08:00</published><updated>2025-01-21T21:08:31+08:00</updated><id>https://ustb-806.github.io/blogs/2025/01/cursor-experience-review</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2025/01/cursor-experience-review/"><![CDATA[<p>最开始听说 Cursor 这个工具的时候，是在知乎的某个回答里。当时以为这又是一个借着 AI 的热度，套了个 VSCode 的壳的圈钱软件，但当某一天在一次 OpenAI 的发布会上看到展示的员工也用 Cursor 的时后，我才改变了这个鲁莽的想法，决定亲自试一试。毕竟能让世界顶级大厂的人都愿意使用，那肯定是有他的过人之处。</p>
  <p>没想到，这一试，彻底颠覆了我的认知……</p>
  <h2 id="cursor-是什么">Cursor 是什么</h2>
  <p>简单来说，Cursor 是一个 VSCode 的 fork 版本，但是往里面加入了非常多 AI 相关的功能，包括更智能的代码补全，集成内部的 AI 对话框，以及本篇文章的重点内容——Composer 等等。</p>
  <p>你可能会问，这和 VSCode 自己的 Copilot 有什么区别呢？区别大着呢。</p>
  <p>简单概括 Cursor 和 Copilot 的区别：Cursor 的代码补全，不仅是能够补全后面的代码，更重要的是能<strong>对已有的代码进行修改</strong>。并且 Cursor 的上下文不仅局限于当前文件，而是整个工作区（文件夹）内的所有文件，甚至是电脑的剪切板，甚至是之前删掉的某些内容！Cursor 就好像有记忆力一般，用的越久，就越能够明白整个项目的结构。</p>
  <p>拿一个具体的例子来举例。</p>
  <p>我想在博客的 i18n 文件里插入一些新写好的内容。在 Cursor 里，只需要粘贴下来，然后输入第一个 <code class="language-plaintext highlighter-rouge">"</code> 号，接下来就只需要……不停按 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 就好了：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/1.gif" alt="1" /></p>
  <p>或者还可以调用 Cursor 的代码修改功能来实现。这个功能更适合想实现的目标比较复杂，代码补全没法直接通过上下文进行推测的情况。如果生成的有错误，还能通过代码补全自动发现并改正：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/2.gif" alt="2" /></p>
  <p>这些都还只是小场面。</p>
  <p>前段时间在打 OceanBase 比赛的时候，写 C++ 的大项目。C++ 的函数定义和函数实现是分别在 <code class="language-plaintext highlighter-rouge">.cpp</code> 和 <code class="language-plaintext highlighter-rouge">.h</code> 文件里的。如果想要增加一个函数的参数，就必须要在两个地方都进行修改。而且由于 C++ 继承的特性，经常会导致改了一个类的方法，就需要把他派生出来的所有类的方法都进行修改。</p>
  <p>使用 Cursor，只需要在 <code class="language-plaintext highlighter-rouge">.h</code> 文件中增加新的参数，切换到 <code class="language-plaintext highlighter-rouge">.cpp</code> 的实现时，会自动补全，并且还会把所有这个函数的调用都增加新的参数！这让我能够剩下大量的时间，专注于处理思路问题和解决 bug，而不是处理这些苦力活。</p>
  <p>但仅仅是这些功能的话，只是让我觉得这比 Copilot 聪明一些而已，但还不够为了他单独写一篇文章。真正让我觉得颠覆的功能是——Composer。</p>
  <h2 id="革命性的突破composer">革命性的突破——Composer</h2>
  <p>昨天晚上，我在 Bing 站点管理器里查看我的博客数据的时候，突然有个想法——在 GitHub workflow 弄一个脚本，每天凌晨的时候通过 Bing Url API 自动提交博客的最新 10 篇文章，这样就不会浪费每天的提交额度了。</p>
  <p>说干就干，我立刻翻开了 Bing 提交 API 的<a href="https://www.bing.com/webmasters/url-submission-api#APIs">说明文档</a>，但是……看不懂啊！对于一个完全没有写过后端，前端也只是在折腾博客的时候照猫画虎了解了一些的人来说，不花个几个小时系统学习一下这些知识，真的完全没法做到。</p>
  <p>正当想放弃的时候，我突然想到了 Composer。在这之前，除了新手教学以外，我还没用真正用过这个功能呢，那要不就试试吧！</p>
  <p>Composer 是一个增强版的代码修改功能，他能够读取并修改你的整个工作区的所有文件，甚至还能根据要求新建文件，可以说这才是完全体的 Copilot。</p>
  <p>稍微计划了一下，想要实现上述的功能，大概需要分成以下几个步骤：</p>
  <ol>
    <li>将 <code class="language-plaintext highlighter-rouge">/src/content/</code> 下的所有 <code class="language-plaintext highlighter-rouge">md,mdx</code> 格式的文件找出来；</li>
    <li>按照其 <code class="language-plaintext highlighter-rouge">frontmatter</code> 里的 <code class="language-plaintext highlighter-rouge">date</code> 属性进行排序；</li>
    <li>处理成合适的 url 链接；</li>
    <li>通过 Bing 提交 API 进行提交。</li>
  </ol>
  <p>开始行动！直接开门见山，告诉他帮我找出最新的 10 篇文章：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/3.gif" alt="3" /></p>
  <p>写得很快，但是报错了……尴尬，难道要出师未捷身先死了吗？</p>
  <p>把错误复制给他：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/4.gif" alt="4" /></p>
  <p>没想到，他通过项目的配置文件知道了我使用的是 ejs，一下子就解决了！有点惊叹。</p>
  <p>那么接下来是把路径处理成 url 的格式。写了个 <code class="language-plaintext highlighter-rouge">baseUrl</code> 代表域名，让他把路径修改成网址：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/5.gif" alt="5" /></p>
  <p>Cursor 竟然连 <code class="language-plaintext highlighter-rouge">baseUrl</code> 都自动补全了，真的震惊！</p>
  <p>但这还不够，文章的 url 是只有年份，没有后面的月和日的，再让他继续处理：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/6.gif" alt="6" /></p>
  <p>哎呀，又出错了，加上了年份但是没有正确去掉月和日。把错误反馈给他：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/7.gif" alt="7" /></p>
  <p>就这么反馈给他一下他就把错误处理好了……这效率太快了。</p>
  <p>那么现在网址处理完成了，接下来就是通过 API 给 Bing 提交。直接把刚刚 Bing 的 API 格式复制给他，让他帮我提交：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/8.gif" alt="8" /></p>
  <p>就这么两下，实现了……我刚刚倒上的水还没喝几口呢……</p>
  <p>但是看返回的信息好像没有成功提交？原来是今天的提交额度不够了，尴尬……那要不然改成一个一个提交，遇到限额满了就停止提交吧：</p>
  <p><img src="https://blog-s3.bosswnx.xyz/2024-12-12-cursor-experience-review/9.gif" alt="9" /></p>
  <p>于是就这么完成了……最后只需要生成一个 GitHub workflow 脚本，让 GitHub 每天定时自动执行就好了。当然，这也只需要一句话的事情，这里就不展示了。</p>
  <p>就这么不到 10 分钟，Cursor 就完成了原本可能需要好几个小时甚至一两天才能实现的功能。而我甚至都不需要学会前端的各种知识，就能轻松实现。</p>
  <p>从此，我再也不需要因为一点小小的需求，而去学习大量无关紧要的知识了。唯一要做的就是把任务进行拆分，然后依次告诉 Cursor 让他帮我实现，遇到错误了就再反馈给他就好了。我甚至不需要复制粘贴……</p>
  <h2 id="现状与未来">现状与未来</h2>
  <p>我敢说，Cursor 是我到目前为止，唯二觉得能算得上是生产力的 AI 工具了，另一个是 ChatGPT。Cursor 利用现在大模型庞大的知识储备，让我能够迅速补上知识层面的漏洞。从此之后我写代码，就好像战场上的指挥官，我只需要指挥，苦力基本上可以依靠 AI 来实现。</p>
  <p>现在 Cursor 支持的最高的模型还仅仅是 claude-3.5，不敢想象如果以后能接入 o1 等更高级的模型，Cursor 的能力会发展成什么样。</p>
  <p>其实相较于图片，视频，音乐等领域，我觉得代码生成才是大模型最能崭露头角的地方，同时也是最容易替代人工的地方。</p>
  <p>虽然 DALL-E、Sora 等模型能生成出来很多高质量的作品，但还是被我们吐槽一眼 AI。究其原因，我觉得还是 AI 生成的过程依旧只是照猫画虎，它并不能理解图片中的各种物理规律，更别说是视频了。</p>
  <p>而且在这种较为「艺术」的领域，我们欣赏一部作品，欣赏的是作者创作这个作品时候的想法，又或者是欣赏某个作者的特殊的风格。我会因为一部电影是诺兰导演的而特意去电影院观看，映后会和朋友讨论片中的各种细节与伏笔，感受诺兰想通过镜头转达给我们的思考。但我若是看到一部 AI 生成的电影，我只会说「哇，这个 AI 好厉害」。</p>
  <p>但是在代码这个领域，目标只要一个——写出符合要求的代码，而这正是现在的 AI 最擅长的。</p>
  <p>人和机器最大的不同，是<em>人有人性</em>。通俗一点来讲，就是人会有喜怒哀乐，会有爱恨情仇，会有希望梦想，会有诗和远方……这些，这是机器不具备的。但很可惜，或许是因为社会的压力，又或者是因为其他原因，有些人已经失去了这部分能力，变成了一个活着的机器了。</p>
  ]]></content><author><name>Nelson Boss</name></author><category term="教程" /><category term="Cursor" /><category term="AI" /><summary type="html"><![CDATA[最开始听说 Cursor 这个工具的时候，是在知乎的某个回答里。当时以为这又是一个借着 AI 的热度，套了个 VSCode 的壳的圈钱软件，但当某一天在一次 OpenAI 的发布会上看到展示的员工也用 Cursor 的时后，我才改变了这个鲁莽的想法，决定亲自试一试。毕竟能让世界顶级大厂的人都愿意使用，那肯定是有他的过人之处。]]></summary></entry><entry><title type="html">如何从零开始可视化一首音乐？</title><link href="https://ustb-806.github.io/blogs/2024/12/visualize-spectumn/" rel="alternate" type="text/html" title="如何从零开始可视化一首音乐？" /><published>2024-12-14T00:00:00+08:00</published><updated>2024-12-14T14:08:51+08:00</updated><id>https://ustb-806.github.io/blogs/2024/12/visualize-spectumn</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/12/visualize-spectumn/"><![CDATA[<p>最近换上了 ArchLinux，体验了众多美观的 TUI 应用。其中我认为最酷炫的当属 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 这个音乐播放器了。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/ncmpcpp_demo.gif" alt="ncmpcpp 的可视化音频效果" /></p>
  <p>日常办公时把它放在屏幕角落，就会感觉工作环境变得更有趣了。这也让我对它的实现产生了巨大的好奇心，于是我决定探索一下它是如何实现的。</p>
  <p>本文将深入底层，从音频编码开始讲起，探究 <code class="language-plaintext highlighter-rouge">wav</code> 格式的音频文件是如何被解析的，然后再讲解如何通过傅立叶变换将音频信号转换为频谱图，最后再着手实现。</p>
  <h1 id="音频编码">音频编码</h1>
  <h2 id="声波">声波</h2>
  <p>中学物理教过我们，声音是一种机械波，由物体振动产生，通过介质传播。当波通过介质传递到耳朵时，耳膜会随之振动，我们才能听到声音。</p>
  <p>声波会引起麦克风（注：这里以动圈式麦克风为例）传感器中的振膜振动，振膜与被磁铁包围着住的线圈相连，根据法拉第定律和楞次定律，振膜振动会使磁场中线圈移动而产生感应电流。此时，只需要监测线圈两极的电压即可得到声音的波形图。机械振动就被转换为了电压信号。</p>
  <p>我们现在得到的是连续的模拟信号，还需要将其转换成计算机可识别的离散的数字信号。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/image.png#full" alt="连续的模拟信号。图片来源@cjting" /></p>
  <p>这时候，我们需要对信号进行模数转换（ADC）。AD 芯片每隔一段时间（几微秒）对波形图打点采样，得到每一个点的电压值，然后量化为二进制数，最后再进行编码，我们就得到了音频波形数据。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/image-1.png#full" alt="采样。图片来源@cjting" /></p>
  <h2 id="wav-格式">WAV 格式</h2>
  <p>和图像、视频一样，音频编码格式也主要分为两大类：有损压缩和无损压缩格式。</p>
  <p><code class="language-plaintext highlighter-rouge">wav</code> 就是一种典型的无损压缩格式，它是由微软和 IBM 共同开发的一种音频文件格式。它被称为“波形文件”，它也是相对好理解的一个音频格式。</p>
  <p>一个完整的 <code class="language-plaintext highlighter-rouge">wav</code> 文件必须包含两个区块：<code class="language-plaintext highlighter-rouge">Format Chunk</code> 和 <code class="language-plaintext highlighter-rouge">Data Chunk</code></p>
  <p>下面是一个包含了以上两个 Chunk 的 WAV 文件的例子：</p>
  <pre><code class="language-plain"> __________________________
| RIFF WAVE Chunk	   |
|   groupID  = 'RIFF'      |
|   riffType = 'WAVE'      |
|    __________________    |
|   | Format Chunk     |   |
|   |	ckID = 'fmt '  |   |
|   |__________________|   |
|    __________________    |
|   | Sound Data Chunk |   |
|   |	ckID = 'data'  |   |
|   |__________________|   |
|__________________________|
</code></pre>
  <p><code class="language-plaintext highlighter-rouge">Format Chunk</code> 包含了重要的描述波形的参数：</p>
  <ul>
    <li>采样率（Sample Rate）：每秒采样模拟信号的次数</li>
    <li>采样宽度（Sample Width）：每个采样点的位数</li>
    <li>声道数量（Audio Channels）</li>
    <li>采样帧总数（Sample Frame）</li>
    <li>压缩方式（Compression Type）</li>
  </ul>
  <p><code class="language-plaintext highlighter-rouge">Data Chunk</code> 包含了实际的波形数据，这些数据由一连串的采样帧组成，按时间顺序排列。</p>
  <p>一个采样点表示一次采样内声音的振幅值。采样点位数越高，可表示的值的范围就越大，音频的质量就越好，但是文件的大小也就越大。一个采样帧包含了一次采样的所有声道的采样点。比如，我有左右两个声道，每个声道有 16 位的采样点，那么一个采样帧就包含了 32 位的数据。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/image-2.png" alt="" /></p>
  <p>在 Python 中，我们可以使用 <code class="language-plaintext highlighter-rouge">wave</code> 模块来读取 <code class="language-plaintext highlighter-rouge">wav</code> 文件：</p>
  <p>440hz_16bit_5s.wav:</p>
  <audio controls="" src="https://blog.soulter.top/images/visualize-music/440hz_16bit_5s.wav" title="440hz_16bit_5s"></audio>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>

<span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">getparams</span><span class="p">())</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
</code></pre>
    </div>
  </div>
  <p>输出如下内容：</p>
  <pre><code class="language-plain">_wave_params(nchannels=1, sampwidth=2, framerate=44100, nframes=220500, comptype='NONE', compname='not compressed')
b'\x00\x00\x8d\x05\x13\x0b\x8e\x10\xf9\x15M\x1b\x87 \xa0%\x93*Z/\xf33W8\x82&lt;p@\x1eD\x88G\xa9J\x7fM\x07P?R'
</code></pre>
  <p>这段音频有一个声道，每个采样点占 2 byte，采样率为 44100，总共有 220500 个采样帧。220500 / 44100 = 5 秒。</p>
  <p>后面读出的采样帧字符串是一段十六进制转义序列，我们可以使用 <code class="language-plaintext highlighter-rouge">struct</code> 模块来解析：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>
<span class="kn">import</span> <span class="n">struct</span>

<span class="k">def</span> <span class="nf">read_wave</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">nframes</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">getnframes</span><span class="p">()</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="n">nframes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">&lt;</span><span class="si">{</span><span class="n">nframes</span><span class="si">}</span><span class="s">h</span><span class="sh">'</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="nf">read_wave</span><span class="p">(</span><span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
</code></pre>
    </div>
  </div>
  <p>在这里我们解析了前 10 个采样帧，<code class="language-plaintext highlighter-rouge">h</code> 表示短整型，<code class="language-plaintext highlighter-rouge">&lt;</code> 表示小端序。WAVE 文件采用小端序来存储数据。</p>
  <p>输出如下：</p>
  <pre><code class="language-plain">(0, 1421, 2835, 4238, 5625, 6989, 8327, 9632, 10899, 12122)
</code></pre>
  <p>我们发现这一段数字是逐渐增加的，很符合波形的特点。截取前 0.05 秒的波形，然后根据时间绘制波形图：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725975340572.png" alt="" /></p>
  <p>可以发现这是一个正弦波。横轴为时间，纵轴为振幅。由于这段音频的采样宽度为 16 位，所以振幅的范围是 $[-2^{15}, 2^{15}-1]$，即 $[-32768, 32767]$。</p>
  <p>到目前为止，我们已经成功地将音频文件解析为了波形数据，并且成功可视化出了声波振幅随时间变化的波形图。不过，我们想象中的 440Hz 的“可视化图像”应该是那种“只有一个峰”的频谱图，和一开始提到的 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果是一样的。那如何将这种数据转化成频谱图呢？这里，我们需要用到傅立叶变换。</p>
  <h2 id="快速傅立叶变换fft">快速傅立叶变换（FFT）</h2>
  <p>傅立叶变换是一种将信号从时域转换到频域的方法，它可以将一个信号分解为一系列不同频率的正弦波。快速傅立叶变换（FFT）是一种计算傅立叶变换的高效算法。下面是快速傅立叶变换的 Python 实现：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">even</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmath</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2j</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">odd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> \
           <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
</code></pre>
    </div>
  </div>
  <p>它的输入是一系列采样点的振幅值，输出是一系列复数，表示不同频率的正弦波的振幅和相位。让我们把上面的 440Hz 的波形数据输入到这个函数中：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="p">[</span>
    <span class="p">(</span><span class="mi">503643</span><span class="o">+</span><span class="mf">0j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">68801.16613674666</span><span class="o">+</span><span class="mf">116234.4683635989j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">23890.51738479154</span><span class="o">+</span><span class="mf">53037.36938852984j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">16335.061327176663</span><span class="o">+</span><span class="mf">34280.395464007364j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">13741.719659027507</span><span class="o">+</span><span class="mf">24979.846914594244j</span><span class="p">),</span>
    <span class="bp">...</span>
<span class="p">]</span>
</code></pre>
    </div>
  </div>
  <h2 id="可视化频谱">可视化频谱</h2>
  <p>我们将原始波形数据应用于 FFT，然后将得到的复数值转换为其模长，并进行归一化：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="n">spectrum_complex</span><span class="p">,</span> <span class="n">max_value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">将频谱复数转换为振幅，并归一化</span><span class="sh">'''</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">abs</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum_complex</span><span class="p">]</span>
    <span class="n">max_spectrum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">spectrum</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># 防止除以 0
</span>    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">max_value</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">/</span> <span class="n">max_spectrum</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="p">]</span>

<span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">512</span><span class="p">]))[:</span><span class="mi">20</span><span class="p">]</span>
</code></pre>
    </div>
  </div>
  <p>输出：</p>
  <pre><code class="language-plain">[0, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
  <p>是不是有感觉了？！我们采用了前 512 个采样帧的频谱数据，并将它们缩放到 0-10 的范围内，然后取前 20 个频率的振幅值。我们可以使用 <code class="language-plaintext highlighter-rouge">curses</code> 模块来绘制频谱图：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="kn">import</span> <span class="n">curses</span><span class="p">,</span> <span class="n">time</span>

<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="sh">"</span><span class="s">#</span><span class="sh">"</span> <span class="o">*</span> <span class="n">freq</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>

<span class="c1"># （这个 main 函数不是最终版本！）
</span><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">512</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>
        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[:</span><span class="mi">40</span><span class="p">])</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">wrapper</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</code></pre>
    </div>
  </div>
  <p>这里，我们对音频数据进行了分帧处理，每帧 2048 个采样帧，帧移 512 个采样帧。然后我们计算每一帧的频谱，并绘制频谱图。我们可以看到频谱图随时间变化的效果。</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726126824224.png" alt="" /></p>
  <p>现在还有一个小问题，就是这个频谱图的播放时间 (约 8s) 远远高于了实际音乐的播放时间 5s。这是由于我们在每次渲染时，将睡眠时间固定为了 0.05s。没有考虑实际音乐的播放速度和一次循环所用到的采样帧占总采样帧的比例。并且，计算 FFT 和渲染频谱图也是会消耗时间的。</p>
  <p>这也很好解决，为了使可视化跟上音乐的播放速度，我们需要知道音乐的总长度、每一个可视化帧应该的播放时间、可视化帧运算和渲染花费的时间，然后动态调整睡眠时间：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1024</span>

    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>
        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[:</span><span class="mi">40</span><span class="p">],</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span><span class="p">,</span> <span class="n">total_duration</span><span class="p">)</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="c1"># 将可视化帧播放时间剪去运算渲染消耗的时间，来达到自适应。
</span>        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="p">(</span><span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)))</span>
</code></pre>
    </div>
  </div>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726128923283.png" alt="" /></p>
  <p>接下来，我们来优化这个播放器。比如：不同振幅采用不同的颜色、把频谱图横过来、平滑可视化帧之间的振幅。让我们来进行优化</p>
  <p>按照缩放振幅最大值的 0.2、0.4、0.6 倍分割成 4 段，分别采用淡蓝、白、绿、黄颜色区分。</p>
  <p>初始化 curses 的颜色对：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">init_colors</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">start_color</span><span class="p">()</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_CYAN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_WHITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_GREEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">MAX_VALUE</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.6</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre>
    </div>
  </div>
  <p>渲染：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">max_y</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">[:</span><span class="n">max_x</span><span class="p">]</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># 水平展示频谱
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

    <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">curr</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> / </span><span class="si">{</span><span class="n">total</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> s</span><span class="sh">'</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>
</code></pre>
    </div>
  </div>
  <p>然后，我们采用 EMA（移动指数平均）来实现平滑数据。</p>
  <p>EMA 的计算公式为：</p>
  <p>[EMA(t) = (1 - \alpha) \cdot EMA(t-1) + \alpha \cdot x(t)]</p>
  <p>其中 $\alpha$ 为平滑系数，$x(t)$ 为当前值，$EMA(t-1)$ 为上一次的平滑值。</p>
  <p>我们只需要记录上一次的平滑后的频谱值，然后在每一帧的频谱值上应用 EMA 即可。</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>
<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">haruhikage.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">4096</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">2048</span>

    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="n">audio_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">play_audio</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">file_name</span><span class="p">,))</span>
    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

    <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">ema_alpha</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">previous_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># 应用 EMA
</span>            <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ema_alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">ema_alpha</span> <span class="o">*</span> <span class="n">curr</span><span class="p">)</span> <span class="k">for</span> <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">previous_spectrum</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)]</span>

        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span><span class="p">,</span> <span class="n">total_duration</span><span class="p">)</span>
        <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="p">(</span><span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)))</span>

    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
</code></pre>
    </div>
  </div>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726145469076.png" alt="" /></p>
  <p>挺像回事了 hhh。最后，我们再对整个代码进行一轮优化。</p>
  <ol>
    <li>
      <p>第零，既然这是一个可以可视化音频的工具，为什么不能同时播放音乐呢？于是我用了 <code class="language-plaintext highlighter-rouge">simpleaudio</code> 模块，在子线程中同步播放音乐。</p>
    </li>
    <li>
      <p>第一，上面的代码没有考虑窗口自适应，我们需要在每一次循环中都取一次窗口大小 <code class="language-plaintext highlighter-rouge">max_x</code> 和 <code class="language-plaintext highlighter-rouge">max_y</code>，当窗口发生变化时重新计算 <code class="language-plaintext highlighter-rouge">colors</code> 列表。</p>
    </li>
    <li>
      <p>第二，现在的计算方式是一次性将 4096 个采样帧都进行 EMA 计算，实际我们只需要将窗口的 <code class="language-plaintext highlighter-rouge">max_x</code> 个采样帧进行 EMA 计算和存储即可。</p>
    </li>
    <li>
      <p>第三，我通过和实际音乐播放的时间比对发现，整个渲染部分还是会有延迟（基本上每秒会有 0.003 秒的延迟），如果任由其累加，到了后面，实际的音频播放会和可视化频谱有很大的错位。我直接计算了实际播放时间和可视化帧时间的差，将其作为 <code class="language-plaintext highlighter-rouge">delay</code>，然后在 time.sleep() 时直接减去这个 <code class="language-plaintext highlighter-rouge">delay</code>，这样就能在单次帧渲染时把 delay 给消除。</p>
    </li>
    <li>
      <p>第四，测试发现很多振幅低的频率在频谱图中几乎不可见，这是因为我们采用的是线性归一化，高振幅的频率会压缩低振幅的频率。我们可以换成平方根归一化，这样可以减少高低频率振幅的差距。</p>
    </li>
    <li>
      <p>第五，我发现渲染帧率太高了，而帧之间的振幅变化又太快，导致频谱图看起来很闪烁。于是我设置了一个固定的帧率 <code class="language-plaintext highlighter-rouge">fps</code> 和频谱数据缓冲区，其大小为 <code class="language-plaintext highlighter-rouge">frame_duration / (1/fps)</code>，频谱数据先放入缓冲区，当缓冲区满时全部取出，并求平均值，然后再进行 EMA 计算和渲染。</p>
      <blockquote>
        <p>后续发现其实调大 <code class="language-plaintext highlighter-rouge">hop_size</code> 就行。想复杂了 = =</p>
      </blockquote>
    </li>
  </ol>
  <p>优化后的完整代码如下：</p>
  <div class="language-python highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>
<span class="kn">import</span> <span class="n">struct</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="kn">import</span> <span class="n">cmath</span>
<span class="kn">import</span> <span class="n">curses</span>
<span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">threading</span>
<span class="kn">import</span> <span class="n">simpleaudio</span> <span class="k">as</span> <span class="n">sa</span>

<span class="k">def</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">wf</span><span class="p">:</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getnchannels</span><span class="p">()</span>
        <span class="n">sample_width</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getsampwidth</span><span class="p">()</span>
        <span class="n">frame_rate</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getframerate</span><span class="p">()</span>
        <span class="n">num_frames</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getnframes</span><span class="p">()</span>

        <span class="n">raw_data</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="n">num_frames</span><span class="p">)</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="n">num_frames</span> <span class="o">*</span> <span class="n">num_channels</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">&lt;</span><span class="si">{</span><span class="n">total_samples</span><span class="si">}</span><span class="s">h</span><span class="sh">"</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">num_channels</span><span class="p">)]</span>  <span class="c1"># 只取一个声道
</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span>

<span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">even</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmath</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2j</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">odd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> \
           <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="n">spectrum_complex</span><span class="p">,</span> <span class="n">max_y</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">将频谱复数转换为振幅，并归一化</span><span class="sh">'''</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="nf">int</span><span class="p">((</span><span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>  <span class="mf">0.8</span><span class="p">)</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">abs</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum_complex</span><span class="p">]</span>
    <span class="n">max_spectrum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">spectrum</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># return [int(max_y * freq / max_spectrum) for freq in spectrum]
</span>    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">max_y</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">max_spectrum</span><span class="p">))</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">play_audio</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="n">wave_obj</span> <span class="o">=</span> <span class="n">sa</span><span class="p">.</span><span class="n">WaveObject</span><span class="p">.</span><span class="nf">from_wave_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    <span class="n">play_obj</span> <span class="o">=</span> <span class="n">wave_obj</span><span class="p">.</span><span class="nf">play</span><span class="p">()</span>
    <span class="n">play_obj</span><span class="p">.</span><span class="nf">wait_done</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">init_colors</span><span class="p">():</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">start_color</span><span class="p">()</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_CYAN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_WHITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_GREEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">max_y</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">max_y</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.6</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ema</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
    <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">prev</span><span class="p">):</span>
            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="c1"># 自适应窗口大小可能会导致 prev 长度小于 curr
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">new</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">haruhikage.wav</span><span class="sh">'</span>
    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1024</span>
    <span class="n">ema_alpha</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1"># EMA 的 alpha
</span>    <span class="n">fps</span> <span class="o">=</span> <span class="mi">40</span>

    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="n">audio_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">play_audio</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">file_name</span><span class="p">,))</span>
    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="n">play_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

    <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># 上一次的频谱
</span>    <span class="n">last_max_y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span> <span class="c1"># 上一次的窗口大小
</span>    <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">last_max_y</span><span class="p">)</span>

    <span class="n">cached_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ideal_frame_time</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">fps</span>
    <span class="n">cached_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">ideal_frame_time</span> <span class="o">//</span> <span class="n">frame_duration</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

        <span class="c1"># 自适应窗口大小
</span>        <span class="n">max_y</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_y</span> <span class="o">!=</span> <span class="n">last_max_y</span><span class="p">:</span>
            <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">max_y</span><span class="p">)</span>
            <span class="n">last_max_y</span> <span class="o">=</span> <span class="n">max_y</span>

        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">])[:</span><span class="n">max_x</span><span class="p">],</span> <span class="n">max_y</span><span class="p">)</span>

        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">cached_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cached_size</span><span class="p">:</span>
            <span class="c1"># 求平均
</span>            <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cached_list</span><span class="p">)]</span>
            <span class="n">cached_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># 应用 EMA
</span>            <span class="k">if</span> <span class="n">previous_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">ema</span><span class="p">(</span><span class="n">ema_alpha</span><span class="p">,</span> <span class="n">previous_spectrum</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)</span>
            <span class="c1"># 渲染频谱
</span>            <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)</span>

            <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cached_list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

        <span class="n">_render_time</span> <span class="o">=</span> <span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="n">_frame_time</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span>
        <span class="n">_actual_frame_time</span> <span class="o">=</span> <span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">play_start_time</span>
        <span class="n">_delay</span> <span class="o">=</span> <span class="n">_actual_frame_time</span> <span class="o">-</span> <span class="n">_frame_time</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="s">(</span><span class="si">{</span><span class="n">_actual_frame_time</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">s) </span><span class="si">{</span><span class="n">_frame_time</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> / </span><span class="si">{</span><span class="n">total_duration</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> s delay: </span><span class="si">{</span><span class="p">(</span><span class="n">_delay</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s render: </span><span class="si">{</span><span class="n">_render_time</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s frame: </span><span class="si">{</span><span class="n">frame_duration</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s</span><span class="sh">'</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>

        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="n">_render_time</span> <span class="o">-</span> <span class="n">_delay</span><span class="p">))</span>

    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">wrapper</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</code></pre>
    </div>
  </div>
  <p>我们用它来播放一下来自 CHYCHIC 的 <code class="language-plaintext highlighter-rouge">haruhikage.wav</code>：</p>
  <p>（该 demo 不是最终版本！下面还有两个优化！！）</p>
  <video controls="" src="https://blog.soulter.top/images/visualize-music/demo_cry.mp4" title="Title" style="width: 100%"></video>
  <p>相比于 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果，还有很多地方需要优化，比如多声道支持、更平滑的频谱图。</p>
  <p>（下面是 Update，已经更新了多声道支持）</p>
  <h2 id="更丝滑的频谱图">更丝滑的频谱图</h2>
  <p>查阅了相关资料，突然发现我们可以设置两个 EMA Alpha，一个是当 prev_spectrum 小于 curr_spectrum 时的 alpha1，一个是当 prev_spectrum 大于 curr_spectrum 时的 alpha2。前者可以让频谱图更快地上升，后者可以让频谱图更慢地下降。这样就可以让频谱图更加丝滑了。</p>
  <p>主函数：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">().</span><span class="nb">file</span>
    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1600</span>

    <span class="c1"># The EMA alpha. Means the weight of the **previous** spectrum.
</span>    <span class="n">ema_alpha_down</span> <span class="o">=</span> <span class="mf">0.93</span> <span class="c1"># when previous value &gt; current value
</span>    <span class="n">ema_alpha_up</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># when previous value &lt;= current value
</span>
    <span class="c1"># ...
</span></code></pre>
    </div>
  </div>
  <p>EMA 函数：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">ema</span><span class="p">(</span><span class="n">alpha_down</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_up</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">prev</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">curr</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">Exponential Moving Average</span><span class="sh">'''</span>
    <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">prev</span><span class="p">):</span>
            <span class="c1"># dynamically adjust the size of terminal window may cause the length of prev and curr to be different
</span>            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">alpha_down</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_down</span><span class="p">)</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">alpha_up</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_up</span><span class="p">)</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">new</span>
</code></pre>
    </div>
  </div>
  <p>效果如下：</p>
  <video controls="" src="https://blog.soulter.top/images/visualize-music/demo2.mp4" title="demo2" style="width: 100%"></video>
  <p>可以发现，在鼓点来时，频谱图上升得很快，而在鼓点过后，频谱图下降得很慢。这样就显得更加丝滑！</p>
  <h2 id="更更丝滑的频谱图">更更丝滑的频谱图</h2>
  <p>在前面的实现中，我们默认绘图的字符是 “█”，然而，它在 unicode 中叫作 “Full block”。它还有 7 个兄弟：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">▁</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▂</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▃</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▄</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▅</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▆</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▇</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">█</span><span class="sh">'</span><span class="p">]</span>
</code></pre>
    </div>
  </div>
  <p>我们可以借此实现更加丝滑的频谱图。</p>
  <p>首先，scale 的最大值可以直接乘以 <code class="language-plaintext highlighter-rouge">len(blocks)</code>：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="n">last_scale_max_val</span> <span class="o">=</span> <span class="nf">int</span><span class="p">((</span><span class="n">max_y</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">)</span>
</code></pre>
    </div>
  </div>
  <p>然后我们的振幅范围就在 [0, last_scale_max_val] 之间。</p>
  <p>在绘图时，前 <code class="language-plaintext highlighter-rouge">val // len(blocks)</code> 个字符使用 <code class="language-plaintext highlighter-rouge">Full Block</code>，最后一个字符使用 <code class="language-plaintext highlighter-rouge">blocks[val % len(blocks)]</code>。</p>
  <p>我们稍加修改 <code class="language-plaintext highlighter-rouge">draw_spectrum</code> 函数：</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">full_1</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">freq</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
        <span class="n">full_2</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
        <span class="n">left_1</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">left_2</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>

        <span class="c1"># draw the full blocks
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">full_1</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if the audio file only has one channel, draw the same spectrum for the other channel
</span>                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="k">continue</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">full_2</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

        <span class="c1"># draw the left blocks
</span>        <span class="k">if</span> <span class="n">left_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">left_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_2</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_2</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</code></pre>
    </div>
  </div>
  <video controls="" src="https://blog.soulter.top/images/visualize-music/demo2.5.mp4" title="demo2.5" style="width: 100%"></video>
  <p>OHHH! 看样子更加丝滑了！… 怎么下面的频谱图变得断断续续了？</p>
  <p>因为我们的 blocks 使用的 unicode 字符的填充是从下往上的，因此就会导致在绘制下半部分频谱图时，末端使用的字符方向不对，导致 full block 和其他 block 之间有间隙。怎么解决呢？似乎 unicode 字符没有从上往下填充的字符。</p>
  <p>一个好办法是创造一个 <code class="language-plaintext highlighter-rouge">colors_reverse</code>，其颜色配置和 <code class="language-plaintext highlighter-rouge">colors</code> 相反，比如 colors 中一个 color 的前景是淡蓝色，背景是黑色，那么 colors_reverse 中这个 color 的前景就是黑色，背景就是淡蓝色。然后我们在绘制频谱图时，将下半部分的频谱图字符颜色设置为 <code class="language-plaintext highlighter-rouge">colors_reverse</code> 中的某个。</p>
  <div class="language-py highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>
<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># ...
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># ...
</span>        <span class="c1"># draw the left blocks
</span>        <span class="k">if</span> <span class="n">left_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors_reverse</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">left_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_2</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors_reverse</span><span class="p">[</span><span class="n">full_2</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</code></pre>
    </div>
  </div>
  <p>效果如下：</p>
  <video controls="" src="https://blog.soulter.top/images/visualize-music/demo3.mp4" title="demo3" style="width: 100%"></video>
  <p>快赶上 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果了！</p>
  <p>后面有时间再继续优化喵。</p>
  <h2 id="附直观理解傅立叶变换">附：直观理解傅立叶变换</h2>
  <p>上文讲到傅立叶变换的基本思想是将一个信号分解为一系列正弦波的叠加。</p>
  <p>拿方波举个例子，下图是一个 5Hz 的方波和一个 5Hz 的正弦波</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976721919.png" alt="" /></p>
  <p>是不是差距蛮大的？那如果我们将 2 个正弦波叠加在一起呢？</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976743585.png" alt="" /></p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976828380.png" alt="" /></p>
  <p>我们会发现，更像方波了。随着我们叠加的正弦波越来越多，我们的波形就会越来越接近方波。</p>
  <p>我们日常听的音乐就是由大量不同频率的正弦波叠加而成的，而傅立叶变换就能够将其分解为一系列不同频率的波。</p>
  <p>为了直观理解傅立叶变换，我参考了 <a href="https://www.youtube.com/watch?v=spUNpyF58BY">@3b1b 的视频</a> 里的方法。</p>
  <p>还是以 5Hz 的正弦波为例。</p>
  <p>440hz_16bit_5s.wav:</p>
  <audio controls="" src="https://blog.soulter.top/images/visualize-music/440hz_16bit_5s.wav" title="440hz_16bit_5s"></audio>
  <p>我们在复平面上从实数轴正半轴开始逆时针转动一个向量：在任意时刻下，向量的模长等于正弦波的振幅，向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">1 Hz</code>，以此绘制得到一个图：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725978427291.png" alt="" /></p>
  <p>它的质心用红点标了出来。</p>
  <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">4.2 Hz</code> 时：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726146180844.png" alt="" /></p>
  <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">4.3 Hz</code> 时：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726146113953.png" alt="" /></p>
  <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">5 Hz</code> 时：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725979910845.png" alt="" /></p>
  <p>有没有发现什么？我们绘制出质心与原点的距离随向量的移动速度变化的图（我们称为“缠绕图像”）：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725979995976.png" alt="" /></p>
  <p>在接近 <code class="language-plaintext highlighter-rouge">5 Hz</code> 时，值最大！！</p>
  <p>同样，我们将 5Hz + 15Hz 的正弦波叠加在一起，再次绘制这个图：</p>
  <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725980156817.png" alt="" /></p>
  <p>极大值点同样出现在 5Hz 和 15Hz 处。</p>
  <p>发生了什么？让我们从公式的角度出发，来解释这个现象。</p>
  <p>由欧拉公式，我们知道，一个圆周运动可以表示为：
    \(e^{2\pi i f t}\)</p>
  <p>其中 $f$ 为频率，$t$ 为时间。</p>
  <p>上述像花一样的缠绕图像可以表示为：</p>
  <p>[g(t) e^{2\pi i t}]</p>
  <p>其中，g(t) 为正弦函数：$ g(t) = \sin(2\pi 5 t) $，也就是一个振幅随时间变化的方程。</p>
  <p>我们需要描述的是其质心在复平面上的坐标的模随时间变化的方程。因此随机取 $N$ 个时间点，计算其质心的坐标，然后取其模长的平均值。</p>
  <table>
    <tbody>
      <tr>
        <td>[\frac{1}{N} \sum_{n=1}^{N}</td>
        <td>g(t_n) e^{2\pi i t_n}</td>
        <td>]</td>
      </tr>
    </tbody>
  </table>
  <p>类似这样，我们对函数作积分，就得到了傅立叶变换：</p>
  <table>
    <tbody>
      <tr>
        <td>[\int_{t_1}^{t_2}</td>
        <td>g(t) e^{2\pi i t}</td>
        <td>dt]</td>
      </tr>
    </tbody>
  </table>
  <p>其值表示的是在 $t_1$ 到 $t_2$ 时刻下，频率为 $f$ 的声波的相对振幅。如果某一个频率的波的强度很大，那么值也会越大。</p>
  <p>看文字不如直接看 <a href="https://www.youtube.com/watch?v=spUNpyF58BY">@3b1b 的视频</a>。</p>
  <h2 id="总结">总结</h2>
  <p>本文介绍了 <code class="language-plaintext highlighter-rouge">wav</code> 的编码结构和傅立叶变换在音频可视化中的应用，并手搓了一个 TUI 的支持频谱可视化的音频播放器。最后，我们通过直观的方式理解了傅立叶变换的基本原理。</p>
  <p>代码开源在了 <a href="https://github.com/soulter/wav-spectrum-visualizer">GitHub</a>，可以去玩玩。</p>
  <h2 id="参考文献">参考文献</h2>
  <p>[1] WAVE File Format. https://web.archive.org/web/20140221054954/http://home.roadrunner.com/~jgglatt/tech/wave.htm</p>
  <p>[2] But what is the Fourier Transform? A visual introduction. https://www.youtube.com/watch?v=spUNpyF58BY</p>
  <p>[3] 为什么要进行傅立叶变换。https://ibillxia.github.io/blog/2013/04/04/why-do-Fourier-transformation/</p>
  ]]></content><author><name>Soulter</name></author><category term="教程" /><category term="音频编码" /><category term="ArchLinux" /><summary type="html"><![CDATA[最近换上了 ArchLinux，体验了众多美观的 TUI 应用。其中我认为最酷炫的当属 ncmpcpp 这个音乐播放器了。]]></summary></entry><entry><title type="html">**勤敏轩 2024**：智潮涌动，硕果盈枝</title><link href="https://ustb-806.github.io/news/2024/12/annual-review/" rel="alternate" type="text/html" title="**勤敏轩 2024**：智潮涌动，硕果盈枝" /><published>2024-12-10T00:00:00+08:00</published><updated>2025-01-21T21:03:46+08:00</updated><id>https://ustb-806.github.io/news/2024/12/annual-review</id><content type="html" xml:base="https://ustb-806.github.io/news/2024/12/annual-review/"><![CDATA[<blockquote>
    <p><strong>勤敏轩 2024</strong>：智潮涌动，硕果盈枝。</p>
  </blockquote>
  <h2 id="勤敏启航创新飞扬">勤敏启航，创新飞扬</h2>
  <p>在充满挑战与机遇的 2024 年，勤敏轩学生创新实验室（简称 806 实验室）秉持着对技术的执着追求和创新的无限热情，走过了充实而辉煌的一年。806 实验室汇聚了众多在校本科生，他们共同致力于计算机专业学科竞赛以及创新创业竞赛的深耕细作。</p>
  <p>实验室下设系统部、人工智能部、游戏部和开发部四个部门，每个部门都承载着不同的使命与梦想。在秋季，我们进行了大规模的招新活动，为实验室注入了新的活力。同时，实验室积极维护自己的官方网站 <a href="https://ustb-806.github.io">https://ustb-806.github.io</a>，为成员们提供了一个展示与交流的平台。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/static/806_2.jpg" alt="alt" />
    勤敏轩实验室</p>
  <h2 id="群英荟萃成就斐然">群英荟萃，成就斐然</h2>
  <h3 id="系统部系统耕耘荣耀绽放">系统部：系统耕耘，荣耀绽放</h3>
  <p>系统部专注于计算机系统能力的培养，在过去的一年里，系统部成员在各类高水平系统能力竞赛中屡获佳绩：</p>
  <ul>
    <li>
      <p>刁明轩同学获得“第八届全国大学生计算机系统能力培养大赛（龙芯杯）”个人赛全国三等奖；</p>
    </li>
    <li>
      <p>丁正枫、王雨辰等同学则荣获“龙芯杯”团体赛全国二等奖；</p>
    </li>
    <li>
      <p>陈宽宽、王诺贤同学在“第四届全国大学生计算机系统能力大赛（操作系统设计赛）内核实现赛道（基于 RISCV 硬件）”中获得了全国二等奖。</p>
    </li>
  </ul>
  <p>这些荣誉的取得，充分展现了系统部成员扎实的专业技能和团队协作精神。</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/02.jpg" alt="alt" />
    “龙芯杯”颁奖典礼，刁明轩（左五）</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-lxb/03.jpg" alt="alt" />
    “龙芯杯”团队赛复赛现场</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-10-02-os-competition/2.jpg" alt="alt" />
    操作系统设计赛</p>
  <h3 id="人工智能部ai-探索智慧引领">人工智能部：AI 探索，智慧引领</h3>
  <p>人工智能部致力于打造优质的 AI 技术学习和开发社群。</p>
  <p>部内成员不仅深入学习了深度学习、CNN、RNN、transformer 等传统模型，还积极参与各类算法竞赛，如计算机设计大赛等，取得了市级二、三等奖的优异成绩。</p>
  <p>祁珏瑜、王苏晴等多名成员还在本校、中科院课题组参与项目实习，发表论文，展现了实验室在 AI 领域的深厚底蕴。</p>
  <h3 id="开发部开发实践创新无限">开发部：开发实践，创新无限</h3>
  <p>开发部涉猎 Android、iOS 客户端、前后端开发、嵌入式开发、AIGC 等应用层领域。</p>
  <p>在过去的一年里，开发部成员在 github 上开源了多个项目，如廖玮珑的 <a href="https://github.com/Soulter/AstrBot">AstrBot</a>、<a href="https://github.com/Soulter/hugging-chat-api">hugging-chat-api</a> 等，获得了广泛好评。同时，他们还开发了 WordEase 英语学习软件，为学校和开源社区做出了宝贵贡献。</p>
  <p>此外，祁珏瑜、崔永亮等成员还开发了 stable-diffusion 插件，进一步丰富了实验室的技术储备。</p>
  <h3 id="游戏部游戏创想乐趣无限">游戏部：游戏创想，乐趣无限</h3>
  <p>游戏部是实验室中充满活力和创意的部门。他们专注于游戏开发与设计，旨在培养成员的游戏制作能力和团队合作精神。</p>
  <p>在过去的一年里，游戏部成员不仅参加了计算机设计大赛并荣获国家三等奖的成绩，还积极实习并担任 Unity 开发的岗位。</p>
  <p>未来，他们计划以月为单位稳定产出游戏作品，并参加各类线上或线下 gamejam 比赛，为实验室的游戏事业贡献力量。</p>
  <h2 id="荣誉满载成果斐然">荣誉满载，成果斐然</h2>
  <p>在全体成员的共同努力下，806 实验室在 2024 年取得了丰硕的成果。实验室一共获得 <strong>国奖 18 项、省（市）奖 19 项、校奖 2 项、软著 2 项以及论文 2 篇</strong>。这些荣誉的取得不仅是对实验室成员努力的肯定，更是对实验室整体实力的彰显。</p>
  <table>
    <thead>
      <tr>
        <th>奖项名称</th>
        <th>获奖者</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>CCPC 中国大学生程序设计竞赛（区域赛）铜奖</td>
        <td>王诺贤</td>
      </tr>
      <tr>
        <td>ICPC 国际大学生程序设计竞赛（区域赛）铜奖</td>
        <td>王诺贤</td>
      </tr>
      <tr>
        <td>ICPC 国际大学生程序设计竞赛（区域赛）铜奖</td>
        <td>陈宽宽</td>
      </tr>
      <tr>
        <td>操作系统设计赛全国二等奖</td>
        <td>陈宽宽、王诺贤</td>
      </tr>
      <tr>
        <td>龙芯杯团体赛全国二等奖</td>
        <td>王雨辰、丁正枫</td>
      </tr>
      <tr>
        <td>龙芯杯个人赛全国三等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>数据库管理系统设计赛优胜奖</td>
        <td>廖玮珑、王诺贤</td>
      </tr>
      <tr>
        <td>蓝桥杯程序设计大赛 C/C++ A 组国家三等奖</td>
        <td>王诺贤</td>
      </tr>
      <tr>
        <td>网络技术挑战赛三等奖</td>
        <td>唐学彬</td>
      </tr>
      <tr>
        <td>全国大学生计算机博弈大赛冠军</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>全国大学生计算机博弈大赛一等奖</td>
        <td>丁正枫</td>
      </tr>
      <tr>
        <td>全国大学生计算机博弈大赛二等奖</td>
        <td>廖玮珑</td>
      </tr>
      <tr>
        <td>“大唐杯”全国大学生新一代信息通信技术大赛国家二等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛国家二等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛国家三等奖</td>
        <td>刁明轩、张溪延、黄昊、韩连伟</td>
      </tr>
      <tr>
        <td>挑战杯揭榜挂帅“虚拟环境中核工程设备运动属性转换与交互技术研究”全国二等奖</td>
        <td>黄昊</td>
      </tr>
      <tr>
        <td>挑战杯全国二等奖</td>
        <td>陈宽宽</td>
      </tr>
      <tr>
        <td>全国青年科普创新实验大赛二等奖</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>计算机系统能力大赛 OceanBase 数据库赛道北京市第一名</td>
        <td>王诺贤、廖玮珑</td>
      </tr>
      <tr>
        <td>计算机系统能力大赛 OceanBase 数据库赛道北京市第三名</td>
        <td>陈宽宽、刁明轩</td>
      </tr>
      <tr>
        <td>蓝桥杯程序设计大赛 C/C++ A 组省级二等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>蓝桥杯程序设计大赛 Python 组省级二等奖</td>
        <td>廖玮珑</td>
      </tr>
      <tr>
        <td>大学生数学竞赛省级一等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>集成电路设计大赛北京市一等奖</td>
        <td>丁正枫</td>
      </tr>
      <tr>
        <td>集成电路设计大赛北京市一等奖</td>
        <td>王雨辰</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛北京市二等奖</td>
        <td>李睿琦</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛北京市三等奖</td>
        <td>朱博林</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛北京市三等奖</td>
        <td>崔永亮、张灿、祁珏瑜、陈铎友</td>
      </tr>
      <tr>
        <td>中国大学生计算机设计大赛北京市三等奖</td>
        <td>周奔成</td>
      </tr>
      <tr>
        <td>华北五省计算机大赛省级三等奖</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>机器人先进视觉赛二等奖</td>
        <td>王诺贤</td>
      </tr>
      <tr>
        <td>全国大学生数学建模国赛北京市二等奖</td>
        <td>刘彦甫</td>
      </tr>
      <tr>
        <td>全国大学生数学建模大赛北京市二等奖</td>
        <td>吴祥楠</td>
      </tr>
      <tr>
        <td>互联网 + 北京市级三等奖</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>京彩大创“百强创业团队”</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>智能汽车竞赛二等奖</td>
        <td>丁正枫</td>
      </tr>
      <tr>
        <td>大学生创新创业大赛二等奖</td>
        <td>张灿</td>
      </tr>
      <tr>
        <td>全国大学生电子设计大赛北京市二等奖</td>
        <td>吴祥楠</td>
      </tr>
      <tr>
        <td>LoongArch32R 自主指令集下单周期处理器教学设计与应用</td>
        <td>崔晓龙，王雨辰，张磊，刘欣，林耀虎</td>
      </tr>
      <tr>
        <td>Fast Adaptation Mechanism for Intelligent Routing in Dynamic Networks Based on Transfer Learning</td>
        <td>Xiaolong Cui, Yuchen Wang, Xinyi Xu, Wei Huangfu, Jiahao Huo</td>
      </tr>
      <tr>
        <td>Intelligent art factory: achieving creative automation through parallel art agents</td>
        <td>Chao GUO1, Xingyuan DAI1, Weilong LIAO2, Jueyu QI2, Yue LU3, Qinghua NI4, Lin WANG5, Fei-Yue WANG1</td>
      </tr>
      <tr>
        <td>材料基因智能计算集成系统软著</td>
        <td>刁明轩</td>
      </tr>
      <tr>
        <td>心血管病智能辅诊系统</td>
        <td>刁明轩</td>
      </tr>
    </tbody>
  </table>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-12-10-annual-review/competition1.jpg" alt="alt" />
    证书展柜 1</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-12-10-annual-review/competition2.jpg" alt="alt" />
    证书展柜 2</p>
  <h2 id="硕果累累保研名校">硕果累累，保研名校</h2>
  <p>值得一提的是，806 实验室的大四学生在学业上也取得了令人瞩目的成绩，<strong>大四同学全部保研</strong>。他们凭借扎实的专业技能和出色的综合素质，成功保研至 <strong>北大、南大、北航、国科大、北科、北邮</strong> 等顶尖院校。这一成绩的取得不仅为实验室增添了光彩，更为成员们的未来发展奠定了坚实的基础。</p>
  <h2 id="智领未来续写辉煌">智领未来，续写辉煌</h2>
  <p>展望未来，806 实验室将继续秉承“勤于思，敏于行”的实验室精神，不断探索新技术、新领域，为培养更多优秀的计算机人才贡献力量。我们坚信，在全体成员的共同努力下，806 实验室必将迎来更加辉煌的明天！</p>
  ]]></content><author><name>cxl</name></author><category term="总结" /><category term="年终总结" /><summary type="html"><![CDATA[勤敏轩 2024：智潮涌动，硕果盈枝。]]></summary></entry><entry><title type="html">配置校园网 IPv6 免流</title><link href="https://ustb-806.github.io/blogs/2024/11/ipv6/" rel="alternate" type="text/html" title="配置校园网 IPv6 免流" /><published>2024-11-21T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/ipv6</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/ipv6/"><![CDATA[<p>本文介绍如何在校园网环境内利用教育网 IPv6 进行免流。</p>
  <h2 id="前提">前提</h2>
  <p>校园网免流基于 IPv6 流量不计费，所以要先确定自己使用的无线网/有线网是否支持 IPv6。</p>
  <h2 id="原理">原理</h2>
  <p>校园网同时支持 IPv4 和 IPv6，但是使用 IPV6 并不计费，因此本地通过 IPv6 协议向服务器发送请求，服务器获取到网络资源后再通过 IPv6 将数据发送到本地，就相当于全程使用 IPv6 与互联网进行数据交互。</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629155642916.png" alt="image-20240629155642916" /></p>
  <h2 id="租服务器">租服务器</h2>
  <p>首先我们要租一台代替我们在互联网上下载资源的服务器，或者准确一些，「VPS」。</p>
  <blockquote>
    <p>虚拟专用服务器（Virtual Private Server，简称 VPS）技术，是将一台服务器分割成多个虚拟专享服务器的优质服务。实现 VPS 的技术分为容器技术，和虚拟化技术。在容器或虚拟机中，每个 VPS 都可选配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。——百度百科</p>
  </blockquote>
  <p>那么该租用一个什么样的 VPS 以及在哪里租比较合适呢？</p>
  <p>首先，为了能够保证网络的流畅，我们要证低延迟和高带宽，此外，我们平时也需要科学上网，但能够找到的机场要么贵要么慢，不妨我们直接搞一个既能科学上网又能免流的 VPS。那么我认为 VPS 的位置最合适的就是香港，不仅能访问到大多数外网的资源又能保证不会在使用免流的时候访问不了国内一些网站。</p>
  <p>那么接下来就是 VPS 租用平台的选取，首先排除阿里云等平台，不仅贵而且带宽仅能给到 30Mb/s。在寻找了一段时间之后，我找到了 <a href="https://churros.cloud/index.php">Churros</a> 这个平台，在这可以租到带宽最多为 625Mb/s。</p>
  <p>注册好账号之后，订购新服务：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163011540.png" alt="image-20240629163011540" /></p>
  <p>选择第一个：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163126172.png" alt="image-20240629163126172" /></p>
  <p>进入之后选择详细的服务：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163244014.png" alt="image-20240629163244014" /></p>
  <p>其中 CPU 一核，RAM 1G，存储 10G 就够用。带宽 1Gbps 就是上限 125Mb/s。流量根据自己需求选择，记得一定要有一个 IPv6 地址，否则无法免流。下面的系统可以根据自己的偏好选择，这里以 Ubuntu20.04 LTS 为例。</p>
  <p><strong>记得设定一个自己记得住的 root 密码。</strong></p>
  <p>VPS 设定需要几分钟，设定完成之后在终端中输入：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>ssh root@&lt;你的IPv4地址&gt;
</code></pre>
    </div>
  </div>
  <p>弹出 <code class="language-plaintext highlighter-rouge">Are you sure you want to continue connecting (yes/no/[fingerprint])? </code> 输入 <code class="language-plaintext highlighter-rouge">yes</code>，之后输入自己的密码。</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629170451589.png" alt="image-20240629170451589" /></p>
  <p>成功进入 VPS。</p>
  <h2 id="vps-设定">VPS 设定</h2>
  <p>首先，更新 Ubuntu。终端输入：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>curl
<span class="nb">sudo </span>apt <span class="nb">install </span>socat
<span class="nb">sudo </span>apt <span class="nb">install </span>ufw
</code></pre>
    </div>
  </div>
  <h3 id="安装-x-ui">安装 X-UI</h3>
  <p>终端输入：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>bash &lt;<span class="o">(</span>curl <span class="nt">-Ls</span> https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh<span class="o">)</span>
</code></pre>
    </div>
  </div>
  <p>依次设置账号密码和端口：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629171501501.png" alt="image-20240629171501501" /></p>
  <p>这里我自定义了端口为 <code class="language-plaintext highlighter-rouge">54321</code>，实际上任何端口都可以，自己能记住即可，不必完全相同。</p>
  <h3 id="开放-ufw-防火墙端口">开放 ufw 防火墙端口</h3>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>ufw status   <span class="c"># 查看本地端口开启情况</span>
<span class="nb">sudo </span>ufw <span class="nb">enable</span>   <span class="c"># 开启防火墙，允许访问特定端口</span>
<span class="nb">sudo </span>ufw allow 20
<span class="nb">sudo </span>ufw allow 21
<span class="nb">sudo </span>ufw allow 22
<span class="nb">sudo </span>ufw allow 54321/tcp  <span class="c"># 给 X-UI 面板开放端口</span>
<span class="nb">sudo </span>ufw allow 12345/tcp  <span class="c"># 给后续的 v2ray 开放端口</span>
                          <span class="c"># 如果多人使用根据自己需求再开启几个</span>
<span class="nb">sudo </span>ufw status  <span class="c"># 重新检查端口开放情况</span>
</code></pre>
    </div>
  </div>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629204716087.png" alt="image-20240629204716087" /></p>
  <h3 id="开启-bbr-加速">开启 BBR 加速</h3>
  <p>新的 TCP 拥塞控制算法 BBR (Bottleneck Bandwidth and RTT) 可以让服务器的带宽尽量跑满，并且尽量不要有排队的情况，让网络服务更佳稳定和高效。</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">echo </span>net.core.default_qdisc<span class="o">=</span>fq <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo </span>net.ipv4.tcp_congestion_control<span class="o">=</span>bbr <span class="o">&gt;&gt;</span> /etc/sysctl.conf   <span class="c"># 修改系统变量</span>
sysctl <span class="nt">-p</span>   <span class="c"># 保存</span>
</code></pre>
    </div>
  </div>
  <p>接下来检查是否开启成功。</p>
  <p>分别输入：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>sysctl net.ipv4.tcp_available_congestion_control
lsmod | <span class="nb">grep </span>bbr
</code></pre>
    </div>
  </div>
  <p>如果第一个输出：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>sysctl net.ipv4.tcp_available_congestion_control
net.ipv4.tcp_available_congestion_control <span class="o">=</span> bbr cubic reno
</code></pre>
    </div>
  </div>
  <p>第二个有输出结果（如果失败不会有输出结果）就说明 BBR 开启成功了。</p>
  <h3 id="配置-x-ui">配置 X-UI</h3>
  <p>在浏览器中输入 <code class="language-plaintext highlighter-rouge">&lt;IPv4地址&gt;:&lt;端口号&gt;</code></p>
  <p>如 <code class="language-plaintext highlighter-rouge">103.229.54.***:54321</code> 进行登录</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629190947466.png" alt="image-20240629190947466" /></p>
  <p>在入站列表中配置：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629191636631.png" alt="image-20240629191636631" /></p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629191629249.png" alt="image-20240629191629249" /></p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192247486.png" alt="image-20240629192247486" /></p>
  <p>在操作中点击「二维码」，然后复制：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192346320.png" alt="image-20240629192346320" /></p>
  <h2 id="配置客户端">配置客户端</h2>
  <p>VPS 的配置已经完成，接下来就是要在电脑上使用。</p>
  <h3 id="v2ray-配置">V2ray 配置</h3>
  <p>V2ray 下载：<a href="https://github.com/2dust/v2rayN/releases/download/4.26/v2rayN-Core.zip">下载链接</a>。</p>
  <p>下载后解压，双击「v2rayN」运行。</p>
  <p>在 V2ray 中点击「服务器」，「从剪贴板导入批量 url」</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192535573.png" alt="image-20240629192535573" /></p>
  <p>导入成功如下：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192723613.png" alt="image-20240629192723613" /></p>
  <p>双击，进入编辑，将 IPv4 地址替换为自己的 IPv6 地址：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192853962.png" alt="image-20240629192853962" /></p>
  <p>如下：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193011319.png" alt="image-20240629193011319" /></p>
  <p>点击确定进行保存。</p>
  <p>在任务栏右侧找到 V2ray 的图标，在「服务器」中选择自己的服务器，「系统代理」中选择「自动配置系统代理」，「路由」中选择「全局」。</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193446792.png" alt="image-20240629193446792" /></p>
  <p>在任务管理器中查看网络使用情况，如果全都是 V2ray 用的就代表配置成功了。可以肆意上网了。</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193435397.png" alt="image-20240629193435397" /></p>
  <h2 id="全文完">全文完</h2>
  <blockquote>
    <p>原文链接：<a href="https://fridemn.best/archives/xiao-yuan-wang-mian-liu">https://fridemn.best/archives/xiao-yuan-wang-mian-liu</a></p>
  </blockquote>
  ]]></content><author><name>Fridemn</name></author><category term="教程" /><category term="校园网" /><category term="IPv6" /><summary type="html"><![CDATA[本文介绍如何在校园网环境内利用教育网 IPv6 进行免流。]]></summary></entry><entry><title type="html">如何在 Linux 上部署一个 MC 纯净/整合包服务器</title><link href="https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux/" rel="alternate" type="text/html" title="如何在 Linux 上部署一个 MC 纯净/整合包服务器" /><published>2024-11-20T00:00:00+08:00</published><updated>2025-01-21T21:03:46+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux/"><![CDATA[<blockquote>
    <p>作为 806 系统部的一员，能够在 Linux 服务器上部署一个 MC 服务端是所有人必须要会的技能。——系统部传统</p>
  </blockquote>
  <p>要想和好基友们开黑 MC，一般会采用单人游戏 + 对局域网开放的方式。但是这样有一个弊端：每次游戏的时候都需要主机在线，这对于随时随地都可能想上线种田的大四老登来说是不可容忍的，而 806 正好又不缺服务器，所以在服务器上部署一个 MC 服务端是更合适的方式。</p>
  <p>本文的环境是：</p>
  <ul>
    <li>Ubuntu 24.04 LTS</li>
    <li><a href="https://www.mcmod.cn/modpack/273.html">冬季救援整合包</a>（1.16.5 Forge）</li>
  </ul>
  <p>一些背景知识：</p>
  <ul>
    <li>连接服务器使用 SSH，这里推荐一个很好用的 SSH 客户端 <a href="https://mobaxterm.mobatek.net/">MobaXTerm</a>，其能直接通过自带的 sftp 工具传输文件。</li>
    <li>在服务器上下载文件可以使用 <code class="language-plaintext highlighter-rouge">wget</code>，复制想要下载的文件的链接，直接在终端输入 <code class="language-plaintext highlighter-rouge">wget &lt;下载链接&gt;</code> 回车即可。</li>
    <li>启动游戏推荐使用第三方客户端，这里推荐 <a href="https://afdian.com/p/0164034c016c11ebafcb52540025c377">PCL</a> 和 <a href="https://hmcl.huangyuhui.net/">HMCL</a>，尽量不要用官方启动器，功能贫乏。</li>
  </ul>
  <h2 id="配置-java-环境">配置 Java 环境</h2>
  <p>MC 是用 Java 写的，所以配置 Java 环境也很合理。</p>
  <p>安装 Java 运行环境之前，首先需要知道想要运行的 MC 版本对应的 Java 版本是多少，这里搬运 <a href="https://zh.minecraft.wiki/w/Tutorial:%E6%9B%B4%E6%96%B0Java?variant=zh-cn">MC 官方 Wiki</a> 里关于 Java 版本的说明：</p>
  <table>
    <thead>
      <tr>
        <th>Minecraft 开发版本</th>
        <th>Minecraft 正式版本</th>
        <th>最低要求 Java 版本</th>
        <th>官启绑定 Java 版本</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/24w14a">24w14a</a>及以上</td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.20.5">1.20.5</a>及以上</td>
        <td>Java 21</td>
        <td>21.0.3</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/22w18a">22w18a</a>至<a href="https://zh.minecraft.wiki/w/24w13a">24w13a</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.19">1.19</a>至<a href="https://zh.minecraft.wiki/w/Java版1.20.4">1.20.4</a></td>
        <td>Java 17</td>
        <td>17.0.8</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.18-pre2">1.18-pre2</a>至<a href="https://zh.minecraft.wiki/w/22w17a">22w17a</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.18">1.18</a>至<a href="https://zh.minecraft.wiki/w/Java版1.18.2">1.18.2</a></td>
        <td>Java 17</td>
        <td>17.0.1</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/21w19a">21w19a</a>至<a href="https://zh.minecraft.wiki/w/Java版1.18-pre1">1.18-pre1</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.17">1.17</a>至<a href="https://zh.minecraft.wiki/w/Java版1.17.1">1.17.1</a></td>
        <td>Java 16</td>
        <td>16.0.1</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/21w18a">21w18a</a>及以下</td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.16.5">1.16.5</a>及以下</td>
        <td>Java 8</td>
        <td>1.8.0_51</td>
      </tr>
    </tbody>
  </table>
  <p>由于我需要运行的版本是 1.16.5，因此这里需要安装 Java 8。</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>openjdk-8-jdk
</code></pre>
    </div>
  </div>
  <p>对于其他的 Java 版本，一般来说将上面指令中的 <code class="language-plaintext highlighter-rouge">8</code> 替换成对应的版本号就可以了。</p>
  <p>安装完成后可以使用 <code class="language-plaintext highlighter-rouge">java --version</code> 来查看版本是否正确。</p>
  <p>如果服务器同时安装了多个版本的 Java，可以使用下面的指令来切换默认的 Java 版本：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>update-alternatives <span class="nt">--config</span> java
</code></pre>
    </div>
  </div>
  <h2 id="配置服务端">配置服务端</h2>
  <p>对于原版、Forge 和 Fabric，初始化服务端的方式各不相同。</p>
  <p>国内的 MCSL 维护了一套服务端文件的镜像（<a href="https://sync.mcsl.com.cn/">这里</a>），后文讲到的文件可以先在这里尝试下载。</p>
  <h3 id="原版vanilla">原版（Vanilla）</h3>
  <p>MC 原版的服务端文件可以直接在 Minecraft 官网上下载。直接 Bing/Google 搜索 <code class="language-plaintext highlighter-rouge">minecraft server &lt;版本号&gt; 下载</code>，找到官方网站对应的下载链接即可。下载下来的服务端一般是一个名为 <code class="language-plaintext highlighter-rouge">server.jar</code>的 jar 文件。</p>
  <p>需要注意两点：</p>
  <ul>
    <li>不要用百度，百度只会把你导航到网易（MC 的国内代理，但是依托**）。</li>
    <li>进入官网后，如果你没有挂梯子的话，那么同样会弹窗让你跳转到网易，注意点击下方的 <code class="language-plaintext highlighter-rouge">Stay on Minecraft.net</code> 留在国际版官网。</li>
  </ul>
  <p>当然，也可以使用上面提到的 <a href="https://sync.mcsl.com.cn/core/Vanilla">MCSL 镜像源</a>下载。</p>
  <p>接下来找到一个合适的目录，初始化服务端：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> server.jar nogui
</code></pre>
    </div>
  </div>
  <p>第一次运行服务端，会创建一个 <code class="language-plaintext highlighter-rouge">eula.txt</code>然后报错退出，这个文件的作用是同意许可。使用 vim 或 nano 或其他方式打开，将里面的 <code class="language-plaintext highlighter-rouge">false</code> 改成 <code class="language-plaintext highlighter-rouge">true</code>，保存退出，重新启动即可。</p>
  <p>等到终端出现 <code class="language-plaintext highlighter-rouge">Done!</code> 等文字的时候，说明服务器已经成功启动，此时已经可以直接开始玩了。不过后面会配置一些优化体验的东西，请继续阅读下文。</p>
  <h3 id="forge">Forge</h3>
  <p>Forge 端可以在 <a href="https://files.minecraftforge.net/net/minecraftforge/forge/">Forge 官网</a>上下载（可能需要挂梯子）。当然，也可以使用上面提到的 <a href="https://sync.mcsl.com.cn/core/Forge">MCSL 镜像源</a>下载。</p>
  <p><strong>注意</strong>：Forge 的小版本之间也会出现不兼容的情况，所以如果是配置整合包的话，一定要下载和整合包的 Forge 版本完全一致的服务端。</p>
  <p>下载下来后会得到一个名为 <code class="language-plaintext highlighter-rouge">forge-&lt;游戏版本&gt;-&lt;Forge版本&gt;-installer.jar</code> 的文件。这里我下载的文件名为 <code class="language-plaintext highlighter-rouge">forge-1.16.5-36.2.34-installer.jar</code>。</p>
  <p>找到一个合适的目录，启动：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> forge-1.16.5-36.2.34-installer.jar <span class="nt">--installServer</span>  <span class="c"># 注意要把文件替换为自己下载的</span>
</code></pre>
    </div>
  </div>
  <p>接下来 Forge Installer 会下载一系列文件，包括服务端原始文件，然后自动进行配置。这个阶段需要保持服务器有良好的网络。该过程有可能需要翻墙。</p>
  <p>配置完成之后，会留下一些文件，其中最重要的是三个（注意替换成自己的版本号）：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">forge-1.16.5-36.2.34.jar</code>：Forge 的主体文件，也是 Forge 端运行的入口；</li>
    <li><code class="language-plaintext highlighter-rouge">libraries</code>：资源文件；</li>
    <li><code class="language-plaintext highlighter-rouge">minecraft_server.1.16.5.jar</code>：Forge 运行的服务端文件。</li>
  </ul>
  <p>接下来就可以启动服务器了：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> forge-1.16.5-36.2.34.jar nogui  <span class="c"># 注意把文件替换为自己的</span>
</code></pre>
    </div>
  </div>
  <p>和原版服务器一样，第一次启动会创建 <code class="language-plaintext highlighter-rouge">eula.txt</code> 文件并报错退出，需要将该文件里面的 <code class="language-plaintext highlighter-rouge">false</code> 修改为 <code class="language-plaintext highlighter-rouge">true</code> 保存退出，重新启动即可。</p>
  <p>重新启动服务器后，服务器会生成一系列游戏文件，包括存档文件夹 <code class="language-plaintext highlighter-rouge">world</code> 和放置 mod 的文件夹 <code class="language-plaintext highlighter-rouge">mods</code>。只需要将想要添加的 mod 放入 <code class="language-plaintext highlighter-rouge">mods</code> 文件夹，重新启动，即可加载 mod。</p>
  <p>不过如果是想配置整合包的话，还需要做接下来的工作。</p>
  <p>整合包一般分为两种发布方法，一种是直接把整个游戏打成压缩包，而另一种是采用配置文件压缩包的形式（压缩包内部有一个 <code class="language-plaintext highlighter-rouge">overrides</code> 文件夹，需要从 PCL 等第三方启动器的 <code class="language-plaintext highlighter-rouge">导入整合包</code> 来进行导入）：</p>
  <ul>
    <li>对于第一种方法，需要将压缩包内的 <code class="language-plaintext highlighter-rouge">mods</code>文件夹和所有的与「配置」相关的文件夹都复制到服务器目录下（包括但不限于 <code class="language-plaintext highlighter-rouge">config</code>、<code class="language-plaintext highlighter-rouge">kubejs</code>、<code class="language-plaintext highlighter-rouge">scripts</code>）。<strong>这一步很重要，如果漏掉了任何一个配置文件都可能会导致整合包运行不正确，所以务必仔细检查。</strong></li>
    <li>而对于第二种方法，首先在本地客户端导入整合包，在本地安装完之后，进入游戏版本根目录，将 <code class="language-plaintext highlighter-rouge">mods</code> 文件夹复制到服务器目录下。然后，将配置文件压缩包里 <code class="language-plaintext highlighter-rouge">overrides</code>文件夹下的所有文件复制到服务器目录下即可。</li>
  </ul>
  <p>完成上述操作后，将刚刚启动生成的 <code class="language-plaintext highlighter-rouge">world</code> 文件夹删除（如果没有就不用管了，这一步是因为整合包可能会对地图生成进行改动，需要将原版生成的地图删除了重新生成），重新启动服务端即可。</p>
  <h3 id="fabric">Fabric</h3>
  <p>Fabric 和 Forge 的安装步骤除了下载文件以外基本上相同。</p>
  <p>相比于 Forge 完全不提供中文安装教程，Fabric 提供了一个非常友好的<a href="https://wiki.fabricmc.net/zh_cn:player:tutorials:install_server">官方中文安装教程</a>，请参考这个教程进行安装，然后跳转到 <a href="#forge">Forge 章节</a>的整合包配置部分。</p>
  <h2 id="更多的配置可选">更多的配置（可选）</h2>
  <p>进行完上述的步骤后，服务器文件夹下大致会有以下文件：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-20-how-to-setup-mc-server-on-linux/1.png" alt="" /></p>
  <p>我配置的是 Forge 整合包服务器，所以文件会多出许多，但大致的内容都差不多，多一些少一些差别不大。</p>
  <p>其中和整合包 mod 配置相关的文件有：<code class="language-plaintext highlighter-rouge">config</code>，<code class="language-plaintext highlighter-rouge">kubejs</code>，<code class="language-plaintext highlighter-rouge">defaultconfigs</code>，<code class="language-plaintext highlighter-rouge">worldshape</code>；</p>
  <p>此时，其实就可以启动服务器开始玩了！但是我们还可以再进一步配置一些东西更方便我们运维。</p>
  <h3 id="screen">Screen</h3>
  <p>启动服务器的时候可以使用 screen、tmux 等工具将其挂在后台，这样就可以切断 SSH 连接而不会导致服务器关闭。接下来简单介绍 screen。</p>
  <p>首先安装 screen：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>screen
</code></pre>
    </div>
  </div>
  <p>可以通过指令 <code class="language-plaintext highlighter-rouge">screen</code> 启动一个新的 screen 会话。可以发现，screen 会话和普通的终端没有什么不同，因为其直接沿用了当前终端的配置。不过，screen 会话可以通过快捷键 <code class="language-plaintext highlighter-rouge">&lt;Ctrl-A&gt; + z</code> 来挂起当前会话，通过指令 <code class="language-plaintext highlighter-rouge">screen -r</code> 来重新连接挂起的会话。</p>
  <p>这样每次使用 screen 启动服务器之后，就可以直接关闭终端，让服务器在后台继续运行，下次需要运维的时候重新连接回来即可。</p>
  <h3 id="serverproperties">server.properties</h3>
  <p><code class="language-plaintext highlighter-rouge">server.properties</code> 文件是 MC 服务器的配置文件。我们可以更改里面的一些内容来实现更好的效果：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">allow-flight</code>：建议改为 <code class="language-plaintext highlighter-rouge">true</code>，因为很多整合包提供了飞行的能力，如果不开启的话会被服务器误认为是在作弊而直接踢出；</li>
    <li><code class="language-plaintext highlighter-rouge">difficulty</code>：服务器的难度，有 <code class="language-plaintext highlighter-rouge">peaceful</code>、<code class="language-plaintext highlighter-rouge">easy</code>、<code class="language-plaintext highlighter-rouge">normal</code>和 <code class="language-plaintext highlighter-rouge">hard</code> 四个选项；</li>
    <li><code class="language-plaintext highlighter-rouge">motd</code>：服务器显示在游戏内的说明文字；</li>
    <li><code class="language-plaintext highlighter-rouge">pvp</code>：玩家之间是否相互可以攻击；</li>
    <li><code class="language-plaintext highlighter-rouge">server-port</code>：服务器的端口，如果一台机子上需要运行多个服务器的话，需要分别设置不同的端口才能运行，否则会冲突。</li>
    <li><code class="language-plaintext highlighter-rouge">online-mode</code>：正版验证，开启了的话需要服务器联网才能加入，好处是能有皮肤。</li>
    <li><code class="language-plaintext highlighter-rouge">view-distance</code>：服务器渲染的视距，依照服务器的性能进行调整，如果卡了就调低一点；</li>
  </ul>
  <h3 id="启动参数">启动参数</h3>
  <p>启动服务器的时候可以在 java 指令后添加一些参数来优化性能，这里我只设置了服务器的内存：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> <span class="nt">-Xmx16G</span> <span class="nt">-Xms16G</span> server.jar nogui
</code></pre>
    </div>
  </div>
  <p>其中：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">-Xmx</code>：设置最大内存；</li>
    <li><code class="language-plaintext highlighter-rouge">-Xms</code>：设置最小内存；</li>
    <li><code class="language-plaintext highlighter-rouge">nogui</code>：以命令行模式启动，必须要添加，否在在命令行里会报错。</li>
  </ul>
  <h3 id="开放防火墙端口">开放防火墙端口</h3>
  <p>由于 Ubuntu 默认开启了防火墙 ufw，所以需要在防火墙开放 MC 服务器默认的端口 <code class="language-plaintext highlighter-rouge">25565</code> 才能链接到服务器。</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>ufw allow 25565  <span class="c"># 开放 25565 端口</span>
</code></pre>
    </div>
  </div>
  <p>如果服务器使用了其他的端口的话，需要改成开放对应的其他端口。</p>
  <h3 id="记分板">记分板</h3>
  <p>你可能在看别的人玩服务器的时候发现，可以在 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 键的玩家列表里看到所有玩家的血量，在显示屏右边有一个榜单显示当前死亡数等……这些都是通过原版的记分板实现的。</p>
  <p>在 MC 服务端的控制台输入以下指令：</p>
  <ul>
    <li>
      <p>启用 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 显示血量：</p>
      <div class="language-text highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code>scoreboard objectives add health health "血量"
scoreboard objectives setdisplay list health
</code></pre>
        </div>
    </div>
    </li>
    <li>
      <p>启用侧边栏死亡计数：</p>
      <div class="language-text highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code>scoreboard objectives add deathCount deathCount "死亡数"
scoreboard objectives setdisplay sidebar deathCount
</code></pre>
        </div>
    </div>
    </li>
  </ul>
  <h2 id="配置-mcdreforged可选">配置 MCDReforged（可选）</h2>
  <p>接下来我们会配置一个非常好用的 MC 服务端管理工具 <a href="https://mcdreforged.com/zh-CN">MCDReforged</a>。这个工具是 TIS 服务器开发的，能够在不修改原版任何东西的基础上，给服务端添加很多很好用的功能，比如：自动备份、自动启停、显示玩家位置等。</p>
  <p>MCDReforged 的安装请参考<a href="https://docs.mcdreforged.com/zh-cn/latest/quick_start/index.html">官方手册</a>。注意，安装方式最好选择 pipx，实测在 Ubuntu 24.04 LTS 下只能使用 pipx 安装方式。</p>
  <p>配置好后，每次启动服务器就是在 MCDReforged 的目录下使用指令 <code class="language-plaintext highlighter-rouge">mcdreforged</code> 启动。</p>
  <p>除了接管 MC 那难用的控制台以外，MCDReforged 最好用的功能就是丰富的插件生态。可以查看<a href="https://mcdreforged.com/zh-CN/plugins">官方插件仓库</a>来查找自己喜欢的插件。这里我列举我每次都会安装的几个插件：</p>
  <ul>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/info">Info</a>：能够获取当前服务器的各种信息，例如 CPU 利用率、内存使用率、存档大小等。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/where2go">Where2go</a>：一个功能强大的位置插件，包含共享坐标点、查询玩家位置等功能。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/prime_backup">Prime Backup</a>：一个强大的 MCDR 备份插件，一套先进的 Minecraft 存档备份解决方案。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/hibernate_r/readme">HibernateR</a>：在服务器没有人的时候让服务器休眠，有人连接时开启。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/simple_op">Simple OP</a>：<code class="language-plaintext highlighter-rouge">!!op</code> 以获取 op, <code class="language-plaintext highlighter-rouge">!!restart</code> 以重启服务器。</li>
  </ul>
  <h2 id="本文完">本文完</h2>
  <p>最后是夹带私货时间！</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-11-20-how-to-setup-mc-server-on-linux/banner.png" alt="" />
    猜猜这些都是谁？（提示：全部都是 806 系统部成员）</p>
  <blockquote>
    <p>原文链接：https://blog.bosswnx.xyz/posts/2024/how-to-setup-mc-server-on-linux/</p>
  </blockquote>
  ]]></content><author><name>Nelson Boss</name></author><category term="教程" /><category term="Minecraft" /><category term="Linux" /><summary type="html"><![CDATA[作为 806 系统部的一员，能够在 Linux 服务器上部署一个 MC 服务端是所有人必须要会的技能。——系统部传统]]></summary></entry><entry><title type="html">OceanBase 2024 比赛资源汇总</title><link href="https://ustb-806.github.io/blogs/2024/11/oceanbase/" rel="alternate" type="text/html" title="OceanBase 2024 比赛资源汇总" /><published>2024-11-12T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/oceanbase</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/oceanbase/"><![CDATA[<p>全国大学生计算机系统能力大赛（OceanBase 数据库大赛）于 2024/10/18 正式开始。下面汇总了比赛的各种资源、赛后总结以供大家参考。</p>
  <h2 id="初赛miniob">初赛（MiniOB）</h2>
  <p>资源信息：</p>
  <ul>
    <li>比赛链接：<a href="https://open.oceanbase.com/train?questionId=600010">MiniOB 训练营</a></li>
    <li><a href="https://open.oceanbase.com/competition/armory">数据库大赛英雄榜</a></li>
    <li><a href="https://oceanbase.github.io/miniob/">MiniOB 辅助开发手册</a></li>
    <li><a href="https://www.oceanbase.com/docs/-developer-quickstart-10000000000627360">MiniOB 官方手册</a></li>
    <li>MiniOB 官方教学视频：
      <ul>
        <li><a href="https://www.oceanbase.com/video/9000654">1-1 数据库系统概述…</a></li>
        <li><a href="https://open.oceanbase.com/activities/4921877?id=4921946">从 0 到 1 数据库内核实战教程</a></li>
      </ul>
    </li>
  </ul>
  <p>实用工具：</p>
  <ul>
    <li>MySQL 语法：<a href="https://www.runoob.com/sql/sql-syntax.html">SQL 语法 - 菜鸟教程</a></li>
    <li>在线运行 MySQL：<a href="https://onecompiler.com/mysql/">MySQL - OneCompiler</a></li>
  </ul>
  <p>赛后总结：</p>
  <table>
    <thead>
      <tr>
        <th>队伍 &amp; GitHub 仓库</th>
        <th>成员</th>
        <th>总结</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="https://github.com/bosswnx/miniob-2024">我真的参加了系统内核赛</a></td>
        <td>王诺贤</td>
        <td><a href="https://zhuanlan.zhihu.com/p/5953505884">OceanBase 2024 初赛 MiniOB 开发记录</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>廖玮珑</td>
        <td><a href="https://blog.soulter.top/posts/2024-oceanbase-database.html">OceanBase 数据库内核实现赛 / 自己实现一个数据库</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>陈渠</td>
        <td><a href="https://blog.virtualfuture.top/posts/miniob/">OceanBase 数据库大赛初赛结束之后</a></td>
      </tr>
      <tr>
        <td><a href="https://github.com/SaZiKK/miniob-2024">我一定要参加编译系统实现赛</a></td>
        <td>陈宽宽</td>
        <td><a href="https://sazikk.github.io/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97-OceanBase%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%83%BD%E5%8A%9B%E5%A4%A7%E8%B5%9B%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/">【开发日志】OceanBase 数据库系统能力大赛开发日志</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>刁明轩</td>
        <td><a href="https://dmx20070206.github.io/2024/11/11/miniob/">miniob 初赛参赛总结</a></td>
      </tr>
    </tbody>
  </table>
  <h2 id="决赛oceanbase">决赛（OceanBase）</h2>
  <p>信息汇总中……</p>
  ]]></content><author><name>USTB-806</name></author><category term="竞赛" /><category term="计算机系统能力大赛" /><category term="OceanBase" /><summary type="html"><![CDATA[全国大学生计算机系统能力大赛（OceanBase 数据库大赛）于 2024/10/18 正式开始。下面汇总了比赛的各种资源、赛后总结以供大家参考。]]></summary></entry></feed>