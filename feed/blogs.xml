<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://ustb-806.github.io/feed/blogs.xml" rel="self" type="application/atom+xml" /><link href="https://ustb-806.github.io/" rel="alternate" type="text/html" /><updated>2025-01-21T21:05:15+08:00</updated><id>https://ustb-806.github.io/feed/blogs.xml</id><title type="html">806 @ USTB | Blogs</title><subtitle>北京科技大学「勤敏轩」学生创新实验室</subtitle><author><name>USTB-806</name></author><entry><title type="html">如何从零开始可视化一首音乐？</title><link href="https://ustb-806.github.io/blogs/2024/12/visualize-spectumn/" rel="alternate" type="text/html" title="如何从零开始可视化一首音乐？" /><published>2024-12-14T00:00:00+08:00</published><updated>2024-12-14T14:08:51+08:00</updated><id>https://ustb-806.github.io/blogs/2024/12/visualize-spectumn</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/12/visualize-spectumn/"><![CDATA[<p>最近换上了 ArchLinux，体验了众多美观的 TUI 应用。其中我认为最酷炫的当属 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 这个音乐播放器了。</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/ncmpcpp_demo.gif" alt="ncmpcpp 的可视化音频效果" /></p>
      <p>日常办公时把它放在屏幕角落，就会感觉工作环境变得更有趣了。这也让我对它的实现产生了巨大的好奇心，于是我决定探索一下它是如何实现的。</p>
      <p>本文将深入底层，从音频编码开始讲起，探究 <code class="language-plaintext highlighter-rouge">wav</code> 格式的音频文件是如何被解析的，然后再讲解如何通过傅立叶变换将音频信号转换为频谱图，最后再着手实现。</p>
      <h1 id="音频编码">音频编码</h1>
      <h2 id="声波">声波</h2>
      <p>中学物理教过我们，声音是一种机械波，由物体振动产生，通过介质传播。当波通过介质传递到耳朵时，耳膜会随之振动，我们才能听到声音。</p>
      <p>声波会引起麦克风（注：这里以动圈式麦克风为例）传感器中的振膜振动，振膜与被磁铁包围着住的线圈相连，根据法拉第定律和楞次定律，振膜振动会使磁场中线圈移动而产生感应电流。此时，只需要监测线圈两极的电压即可得到声音的波形图。机械振动就被转换为了电压信号。</p>
      <p>我们现在得到的是连续的模拟信号，还需要将其转换成计算机可识别的离散的数字信号。</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/image.png#full" alt="连续的模拟信号。图片来源@cjting" /></p>
      <p>这时候，我们需要对信号进行模数转换（ADC）。AD 芯片每隔一段时间（几微秒）对波形图打点采样，得到每一个点的电压值，然后量化为二进制数，最后再进行编码，我们就得到了音频波形数据。</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/image-1.png#full" alt="采样。图片来源@cjting" /></p>
      <h2 id="wav-格式">WAV 格式</h2>
      <p>和图像、视频一样，音频编码格式也主要分为两大类：有损压缩和无损压缩格式。</p>
      <p><code class="language-plaintext highlighter-rouge">wav</code> 就是一种典型的无损压缩格式，它是由微软和 IBM 共同开发的一种音频文件格式。它被称为“波形文件”，它也是相对好理解的一个音频格式。</p>
      <p>一个完整的 <code class="language-plaintext highlighter-rouge">wav</code> 文件必须包含两个区块：<code class="language-plaintext highlighter-rouge">Format Chunk</code> 和 <code class="language-plaintext highlighter-rouge">Data Chunk</code></p>
      <p>下面是一个包含了以上两个 Chunk 的 WAV 文件的例子：</p>
      <pre><code class="language-plain"> __________________________
| RIFF WAVE Chunk	   |
|   groupID  = 'RIFF'      |
|   riffType = 'WAVE'      |
|    __________________    |
|   | Format Chunk     |   |
|   |	ckID = 'fmt '  |   |
|   |__________________|   |
|    __________________    |
|   | Sound Data Chunk |   |
|   |	ckID = 'data'  |   |
|   |__________________|   |
|__________________________|
</code></pre>
      <p><code class="language-plaintext highlighter-rouge">Format Chunk</code> 包含了重要的描述波形的参数：</p>
      <ul>
        <li>采样率（Sample Rate）：每秒采样模拟信号的次数</li>
        <li>采样宽度（Sample Width）：每个采样点的位数</li>
        <li>声道数量（Audio Channels）</li>
        <li>采样帧总数（Sample Frame）</li>
        <li>压缩方式（Compression Type）</li>
      </ul>
      <p><code class="language-plaintext highlighter-rouge">Data Chunk</code> 包含了实际的波形数据，这些数据由一连串的采样帧组成，按时间顺序排列。</p>
      <p>一个采样点表示一次采样内声音的振幅值。采样点位数越高，可表示的值的范围就越大，音频的质量就越好，但是文件的大小也就越大。一个采样帧包含了一次采样的所有声道的采样点。比如，我有左右两个声道，每个声道有 16 位的采样点，那么一个采样帧就包含了 32 位的数据。</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/image-2.png" alt="" /></p>
      <p>在 Python 中，我们可以使用 <code class="language-plaintext highlighter-rouge">wave</code> 模块来读取 <code class="language-plaintext highlighter-rouge">wav</code> 文件：</p>
      <p>440hz_16bit_5s.wav:</p>
      <audio controls="" src="https://blog.soulter.top/images/visualize-music/440hz_16bit_5s.wav" title="440hz_16bit_5s"></audio>
      <div class="language-python highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>

<span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">getparams</span><span class="p">())</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
</code></pre>
        </div>
      </div>
      <p>输出如下内容：</p>
      <pre><code class="language-plain">_wave_params(nchannels=1, sampwidth=2, framerate=44100, nframes=220500, comptype='NONE', compname='not compressed')
b'\x00\x00\x8d\x05\x13\x0b\x8e\x10\xf9\x15M\x1b\x87 \xa0%\x93*Z/\xf33W8\x82&lt;p@\x1eD\x88G\xa9J\x7fM\x07P?R'
</code></pre>
      <p>这段音频有一个声道，每个采样点占 2 byte，采样率为 44100，总共有 220500 个采样帧。220500 / 44100 = 5 秒。</p>
      <p>后面读出的采样帧字符串是一段十六进制转义序列，我们可以使用 <code class="language-plaintext highlighter-rouge">struct</code> 模块来解析：</p>
      <div class="language-python highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>
<span class="kn">import</span> <span class="n">struct</span>

<span class="k">def</span> <span class="nf">read_wave</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">nframes</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">getnframes</span><span class="p">()</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="n">nframes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">&lt;</span><span class="si">{</span><span class="n">nframes</span><span class="si">}</span><span class="s">h</span><span class="sh">'</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="nf">read_wave</span><span class="p">(</span><span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
</code></pre>
        </div>
      </div>
      <p>在这里我们解析了前 10 个采样帧，<code class="language-plaintext highlighter-rouge">h</code> 表示短整型，<code class="language-plaintext highlighter-rouge">&lt;</code> 表示小端序。WAVE 文件采用小端序来存储数据。</p>
      <p>输出如下：</p>
      <pre><code class="language-plain">(0, 1421, 2835, 4238, 5625, 6989, 8327, 9632, 10899, 12122)
</code></pre>
      <p>我们发现这一段数字是逐渐增加的，很符合波形的特点。截取前 0.05 秒的波形，然后根据时间绘制波形图：</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725975340572.png" alt="" /></p>
      <p>可以发现这是一个正弦波。横轴为时间，纵轴为振幅。由于这段音频的采样宽度为 16 位，所以振幅的范围是 $[-2^{15}, 2^{15}-1]$，即 $[-32768, 32767]$。</p>
      <p>到目前为止，我们已经成功地将音频文件解析为了波形数据，并且成功可视化出了声波振幅随时间变化的波形图。不过，我们想象中的 440Hz 的“可视化图像”应该是那种“只有一个峰”的频谱图，和一开始提到的 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果是一样的。那如何将这种数据转化成频谱图呢？这里，我们需要用到傅立叶变换。</p>
      <h2 id="快速傅立叶变换fft">快速傅立叶变换（FFT）</h2>
      <p>傅立叶变换是一种将信号从时域转换到频域的方法，它可以将一个信号分解为一系列不同频率的正弦波。快速傅立叶变换（FFT）是一种计算傅立叶变换的高效算法。下面是快速傅立叶变换的 Python 实现：</p>
      <div class="language-python highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">even</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmath</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2j</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">odd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> \
           <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
</code></pre>
        </div>
      </div>
      <p>它的输入是一系列采样点的振幅值，输出是一系列复数，表示不同频率的正弦波的振幅和相位。让我们把上面的 440Hz 的波形数据输入到这个函数中：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="p">[</span>
    <span class="p">(</span><span class="mi">503643</span><span class="o">+</span><span class="mf">0j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">68801.16613674666</span><span class="o">+</span><span class="mf">116234.4683635989j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">23890.51738479154</span><span class="o">+</span><span class="mf">53037.36938852984j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">16335.061327176663</span><span class="o">+</span><span class="mf">34280.395464007364j</span><span class="p">),</span>
    <span class="p">(</span><span class="o">-</span><span class="mf">13741.719659027507</span><span class="o">+</span><span class="mf">24979.846914594244j</span><span class="p">),</span>
    <span class="bp">...</span>
<span class="p">]</span>
</code></pre>
        </div>
      </div>
      <h2 id="可视化频谱">可视化频谱</h2>
      <p>我们将原始波形数据应用于 FFT，然后将得到的复数值转换为其模长，并进行归一化：</p>
      <div class="language-python highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="k">def</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="n">spectrum_complex</span><span class="p">,</span> <span class="n">max_value</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">将频谱复数转换为振幅，并归一化</span><span class="sh">'''</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">abs</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum_complex</span><span class="p">]</span>
    <span class="n">max_spectrum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">spectrum</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># 防止除以 0
</span>    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">max_value</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">/</span> <span class="n">max_spectrum</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="p">]</span>

<span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[:</span><span class="mi">512</span><span class="p">]))[:</span><span class="mi">20</span><span class="p">]</span>
</code></pre>
        </div>
      </div>
      <p>输出：</p>
      <pre><code class="language-plain">[0, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</code></pre>
      <p>是不是有感觉了？！我们采用了前 512 个采样帧的频谱数据，并将它们缩放到 0-10 的范围内，然后取前 20 个频率的振幅值。我们可以使用 <code class="language-plaintext highlighter-rouge">curses</code> 模块来绘制频谱图：</p>
      <div class="language-python highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="n">curses</span><span class="p">,</span> <span class="n">time</span>

<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">):</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="sh">"</span><span class="s">#</span><span class="sh">"</span> <span class="o">*</span> <span class="n">freq</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>

<span class="c1"># （这个 main 函数不是最终版本！）
</span><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">512</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>
        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[:</span><span class="mi">40</span><span class="p">])</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">wrapper</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</code></pre>
        </div>
      </div>
      <p>这里，我们对音频数据进行了分帧处理，每帧 2048 个采样帧，帧移 512 个采样帧。然后我们计算每一帧的频谱，并绘制频谱图。我们可以看到频谱图随时间变化的效果。</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726126824224.png" alt="" /></p>
      <p>现在还有一个小问题，就是这个频谱图的播放时间 (约 8s) 远远高于了实际音乐的播放时间 5s。这是由于我们在每次渲染时，将睡眠时间固定为了 0.05s。没有考虑实际音乐的播放速度和一次循环所用到的采样帧占总采样帧的比例。并且，计算 FFT 和渲染频谱图也是会消耗时间的。</p>
      <p>这也很好解决，为了使可视化跟上音乐的播放速度，我们需要知道音乐的总长度、每一个可视化帧应该的播放时间、可视化帧运算和渲染花费的时间，然后动态调整睡眠时间：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">440hz_16bit_5s.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1024</span>

    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>
        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">[:</span><span class="mi">40</span><span class="p">],</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span><span class="p">,</span> <span class="n">total_duration</span><span class="p">)</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="c1"># 将可视化帧播放时间剪去运算渲染消耗的时间，来达到自适应。
</span>        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="p">(</span><span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)))</span>
</code></pre>
        </div>
      </div>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726128923283.png" alt="" /></p>
      <p>接下来，我们来优化这个播放器。比如：不同振幅采用不同的颜色、把频谱图横过来、平滑可视化帧之间的振幅。让我们来进行优化</p>
      <p>按照缩放振幅最大值的 0.2、0.4、0.6 倍分割成 4 段，分别采用淡蓝、白、绿、黄颜色区分。</p>
      <p>初始化 curses 的颜色对：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="k">def</span> <span class="nf">init_colors</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">start_color</span><span class="p">()</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_CYAN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_WHITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_GREEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">MAX_VALUE</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">MAX_VALUE</span> <span class="o">&lt;=</span> <span class="mf">0.6</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre>
        </div>
      </div>
      <p>渲染：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">curr</span><span class="p">,</span> <span class="n">total</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">max_y</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">[:</span><span class="n">max_x</span><span class="p">]</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># 水平展示频谱
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

    <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="si">{</span><span class="n">curr</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> / </span><span class="si">{</span><span class="n">total</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> s</span><span class="sh">'</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>
</code></pre>
        </div>
      </div>
      <p>然后，我们采用 EMA（移动指数平均）来实现平滑数据。</p>
      <p>EMA 的计算公式为：</p>
      <p>[EMA(t) = (1 - \alpha) \cdot EMA(t-1) + \alpha \cdot x(t)]</p>
      <p>其中 $\alpha$ 为平滑系数，$x(t)$ 为当前值，$EMA(t-1)$ 为上一次的平滑值。</p>
      <p>我们只需要记录上一次的平滑后的频谱值，然后在每一帧的频谱值上应用 EMA 即可。</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code>
<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">haruhikage.wav</span><span class="sh">'</span>
    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>

    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">4096</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">2048</span>

    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="n">audio_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">play_audio</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">file_name</span><span class="p">,))</span>
    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>

    <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">ema_alpha</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">previous_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># 应用 EMA
</span>            <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ema_alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev</span> <span class="o">+</span> <span class="n">ema_alpha</span> <span class="o">*</span> <span class="n">curr</span><span class="p">)</span> <span class="k">for</span> <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">previous_spectrum</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)]</span>

        <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span><span class="p">,</span> <span class="n">total_duration</span><span class="p">)</span>
        <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="p">(</span><span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)))</span>

    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
</code></pre>
        </div>
      </div>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726145469076.png" alt="" /></p>
      <p>挺像回事了 hhh。最后，我们再对整个代码进行一轮优化。</p>
      <ol>
        <li>
          <p>第零，既然这是一个可以可视化音频的工具，为什么不能同时播放音乐呢？于是我用了 <code class="language-plaintext highlighter-rouge">simpleaudio</code> 模块，在子线程中同步播放音乐。</p>
        </li>
        <li>
          <p>第一，上面的代码没有考虑窗口自适应，我们需要在每一次循环中都取一次窗口大小 <code class="language-plaintext highlighter-rouge">max_x</code> 和 <code class="language-plaintext highlighter-rouge">max_y</code>，当窗口发生变化时重新计算 <code class="language-plaintext highlighter-rouge">colors</code> 列表。</p>
        </li>
        <li>
          <p>第二，现在的计算方式是一次性将 4096 个采样帧都进行 EMA 计算，实际我们只需要将窗口的 <code class="language-plaintext highlighter-rouge">max_x</code> 个采样帧进行 EMA 计算和存储即可。</p>
        </li>
        <li>
          <p>第三，我通过和实际音乐播放的时间比对发现，整个渲染部分还是会有延迟（基本上每秒会有 0.003 秒的延迟），如果任由其累加，到了后面，实际的音频播放会和可视化频谱有很大的错位。我直接计算了实际播放时间和可视化帧时间的差，将其作为 <code class="language-plaintext highlighter-rouge">delay</code>，然后在 time.sleep() 时直接减去这个 <code class="language-plaintext highlighter-rouge">delay</code>，这样就能在单次帧渲染时把 delay 给消除。</p>
        </li>
        <li>
          <p>第四，测试发现很多振幅低的频率在频谱图中几乎不可见，这是因为我们采用的是线性归一化，高振幅的频率会压缩低振幅的频率。我们可以换成平方根归一化，这样可以减少高低频率振幅的差距。</p>
        </li>
        <li>
          <p>第五，我发现渲染帧率太高了，而帧之间的振幅变化又太快，导致频谱图看起来很闪烁。于是我设置了一个固定的帧率 <code class="language-plaintext highlighter-rouge">fps</code> 和频谱数据缓冲区，其大小为 <code class="language-plaintext highlighter-rouge">frame_duration / (1/fps)</code>，频谱数据先放入缓冲区，当缓冲区满时全部取出，并求平均值，然后再进行 EMA 计算和渲染。</p>
          <blockquote>
            <p>后续发现其实调大 <code class="language-plaintext highlighter-rouge">hop_size</code> 就行。想复杂了 = =</p>
          </blockquote>
        </li>
      </ol>
      <p>优化后的完整代码如下：</p>
      <div class="language-python highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="kn">import</span> <span class="n">wave</span>
<span class="kn">import</span> <span class="n">struct</span>
<span class="kn">import</span> <span class="n">math</span>
<span class="kn">import</span> <span class="n">cmath</span>
<span class="kn">import</span> <span class="n">curses</span>
<span class="kn">import</span> <span class="n">time</span>
<span class="kn">import</span> <span class="n">threading</span>
<span class="kn">import</span> <span class="n">simpleaudio</span> <span class="k">as</span> <span class="n">sa</span>

<span class="k">def</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">wave</span><span class="p">.</span><span class="nf">open</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="sh">'</span><span class="s">rb</span><span class="sh">'</span><span class="p">)</span> <span class="k">as</span> <span class="n">wf</span><span class="p">:</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getnchannels</span><span class="p">()</span>
        <span class="n">sample_width</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getsampwidth</span><span class="p">()</span>
        <span class="n">frame_rate</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getframerate</span><span class="p">()</span>
        <span class="n">num_frames</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">getnframes</span><span class="p">()</span>

        <span class="n">raw_data</span> <span class="o">=</span> <span class="n">wf</span><span class="p">.</span><span class="nf">readframes</span><span class="p">(</span><span class="n">num_frames</span><span class="p">)</span>
        <span class="n">total_samples</span> <span class="o">=</span> <span class="n">num_frames</span> <span class="o">*</span> <span class="n">num_channels</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">&lt;</span><span class="si">{</span><span class="n">total_samples</span><span class="si">}</span><span class="s">h</span><span class="sh">"</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">struct</span><span class="p">.</span><span class="nf">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">num_channels</span><span class="p">)]</span>  <span class="c1"># 只取一个声道
</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span>

<span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="n">even</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="nf">fft</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">cmath</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2j</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">k</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">odd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">+</span> \
           <span class="p">[</span><span class="n">even</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">N</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="n">spectrum_complex</span><span class="p">,</span> <span class="n">max_y</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">将频谱复数转换为振幅，并归一化</span><span class="sh">'''</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="nf">int</span><span class="p">((</span><span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>  <span class="mf">0.8</span><span class="p">)</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">abs</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum_complex</span><span class="p">]</span>
    <span class="n">max_spectrum</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="n">spectrum</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># return [int(max_y * freq / max_spectrum) for freq in spectrum]
</span>    <span class="k">return</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">max_y</span> <span class="o">*</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">max_spectrum</span><span class="p">))</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spectrum</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="sh">"</span><span class="s">█</span><span class="sh">"</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

<span class="k">def</span> <span class="nf">play_audio</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="n">wave_obj</span> <span class="o">=</span> <span class="n">sa</span><span class="p">.</span><span class="n">WaveObject</span><span class="p">.</span><span class="nf">from_wave_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    <span class="n">play_obj</span> <span class="o">=</span> <span class="n">wave_obj</span><span class="p">.</span><span class="nf">play</span><span class="p">()</span>
    <span class="n">play_obj</span><span class="p">.</span><span class="nf">wait_done</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">init_colors</span><span class="p">():</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">start_color</span><span class="p">()</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_CYAN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_WHITE</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_GREEN</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">init_pair</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="n">COLOR_YELLOW</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">max_y</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">max_y</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">i</span> <span class="o">/</span> <span class="n">max_y</span> <span class="o">&lt;=</span> <span class="mf">0.6</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ema</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">curr</span><span class="p">):</span>
    <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">prev</span><span class="p">):</span>
            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="c1"># 自适应窗口大小可能会导致 prev 长度小于 curr
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">new</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="sh">'</span><span class="s">haruhikage.wav</span><span class="sh">'</span>
    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1024</span>
    <span class="n">ema_alpha</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="c1"># EMA 的 alpha
</span>    <span class="n">fps</span> <span class="o">=</span> <span class="mi">40</span>

    <span class="n">data</span><span class="p">,</span> <span class="n">frame_rate</span> <span class="o">=</span> <span class="nf">read_wav_file</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
    <span class="n">frame_duration</span> <span class="o">=</span> <span class="n">hop_size</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 每帧的实际播放时间
</span>    <span class="n">total_duration</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">frame_rate</span>  <span class="c1"># 音频总时长
</span>
    <span class="n">audio_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="nc">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">play_audio</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">file_name</span><span class="p">,))</span>
    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">start</span><span class="p">()</span>
    <span class="n">play_start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

    <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># 上一次的频谱
</span>    <span class="n">last_max_y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span> <span class="c1"># 上一次的窗口大小
</span>    <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">last_max_y</span><span class="p">)</span>

    <span class="n">cached_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ideal_frame_time</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">fps</span>
    <span class="n">cached_size</span> <span class="o">=</span> <span class="nf">max</span><span class="p">(</span><span class="n">ideal_frame_time</span> <span class="o">//</span> <span class="n">frame_duration</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">):</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

        <span class="c1"># 自适应窗口大小
</span>        <span class="n">max_y</span><span class="p">,</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">stdscr</span><span class="p">.</span><span class="nf">getmaxyx</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">max_y</span> <span class="o">!=</span> <span class="n">last_max_y</span><span class="p">:</span>
            <span class="nf">adjust_colors</span><span class="p">(</span><span class="n">max_y</span><span class="p">)</span>
            <span class="n">last_max_y</span> <span class="o">=</span> <span class="n">max_y</span>

        <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">scale_spectrum</span><span class="p">(</span><span class="nf">fft</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">frame_size</span><span class="p">])[:</span><span class="n">max_x</span><span class="p">],</span> <span class="n">max_y</span><span class="p">)</span>

        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">cached_list</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">cached_size</span><span class="p">:</span>
            <span class="c1"># 求平均
</span>            <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[</span><span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="o">*</span><span class="n">cached_list</span><span class="p">)]</span>
            <span class="n">cached_list</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># 应用 EMA
</span>            <span class="k">if</span> <span class="n">previous_spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">spectrum</span> <span class="o">=</span> <span class="nf">ema</span><span class="p">(</span><span class="n">ema_alpha</span><span class="p">,</span> <span class="n">previous_spectrum</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">)</span>
            <span class="c1"># 渲染频谱
</span>            <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)</span>

            <span class="n">previous_spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cached_list</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

        <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>

        <span class="n">_render_time</span> <span class="o">=</span> <span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="n">_frame_time</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">frame_rate</span>
        <span class="n">_actual_frame_time</span> <span class="o">=</span> <span class="n">elapsed_time</span> <span class="o">-</span> <span class="n">play_start_time</span>
        <span class="n">_delay</span> <span class="o">=</span> <span class="n">_actual_frame_time</span> <span class="o">-</span> <span class="n">_frame_time</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">max_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="sh">'</span><span class="s">(</span><span class="si">{</span><span class="n">_actual_frame_time</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s">s) </span><span class="si">{</span><span class="n">_frame_time</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> / </span><span class="si">{</span><span class="n">total_duration</span><span class="si">:</span><span class="p">.</span><span class="mi">2</span><span class="n">f</span><span class="si">}</span><span class="s"> s delay: </span><span class="si">{</span><span class="p">(</span><span class="n">_delay</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s render: </span><span class="si">{</span><span class="n">_render_time</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s frame: </span><span class="si">{</span><span class="n">frame_duration</span><span class="si">:</span><span class="p">.</span><span class="mi">5</span><span class="n">f</span><span class="si">}</span><span class="s">s</span><span class="sh">'</span><span class="p">,</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">stdscr</span><span class="p">.</span><span class="nf">refresh</span><span class="p">()</span>

        <span class="n">time</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frame_duration</span> <span class="o">-</span> <span class="n">_render_time</span> <span class="o">-</span> <span class="n">_delay</span><span class="p">))</span>

    <span class="n">audio_thread</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">"</span><span class="s">__main__</span><span class="sh">"</span><span class="p">:</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">curses</span><span class="p">.</span><span class="nf">wrapper</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
</code></pre>
        </div>
      </div>
      <p>我们用它来播放一下来自 CHYCHIC 的 <code class="language-plaintext highlighter-rouge">haruhikage.wav</code>：</p>
      <p>（该 demo 不是最终版本！下面还有两个优化！！）</p>
      <video controls="" src="https://blog.soulter.top/images/visualize-music/demo_cry.mp4" title="Title" style="width: 100%"></video>
      <p>相比于 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果，还有很多地方需要优化，比如多声道支持、更平滑的频谱图。</p>
      <p>（下面是 Update，已经更新了多声道支持）</p>
      <h2 id="更丝滑的频谱图">更丝滑的频谱图</h2>
      <p>查阅了相关资料，突然发现我们可以设置两个 EMA Alpha，一个是当 prev_spectrum 小于 curr_spectrum 时的 alpha1，一个是当 prev_spectrum 大于 curr_spectrum 时的 alpha2。前者可以让频谱图更快地上升，后者可以让频谱图更慢地下降。这样就可以让频谱图更加丝滑了。</p>
      <p>主函数：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">stdscr</span><span class="p">):</span>
    <span class="nf">init_colors</span><span class="p">()</span>
    <span class="n">file_name</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">().</span><span class="nb">file</span>
    <span class="n">frame_size</span> <span class="o">=</span> <span class="mi">2048</span>
    <span class="n">hop_size</span> <span class="o">=</span> <span class="mi">1600</span>

    <span class="c1"># The EMA alpha. Means the weight of the **previous** spectrum.
</span>    <span class="n">ema_alpha_down</span> <span class="o">=</span> <span class="mf">0.93</span> <span class="c1"># when previous value &gt; current value
</span>    <span class="n">ema_alpha_up</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># when previous value &lt;= current value
</span>
    <span class="c1"># ...
</span></code></pre>
        </div>
      </div>
      <p>EMA 函数：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="k">def</span> <span class="nf">ema</span><span class="p">(</span><span class="n">alpha_down</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">alpha_up</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">prev</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">curr</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="sh">'''</span><span class="s">Exponential Moving Average</span><span class="sh">'''</span>
    <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">curr</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">prev</span><span class="p">):</span>
            <span class="c1"># dynamically adjust the size of terminal window may cause the length of prev and curr to be different
</span>            <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">alpha_down</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_down</span><span class="p">)</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">int</span><span class="p">(</span><span class="n">alpha_up</span> <span class="o">*</span> <span class="n">prev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_up</span><span class="p">)</span> <span class="o">*</span> <span class="n">curr</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">new</span>
</code></pre>
        </div>
      </div>
      <p>效果如下：</p>
      <video controls="" src="https://blog.soulter.top/images/visualize-music/demo2.mp4" title="demo2" style="width: 100%"></video>
      <p>可以发现，在鼓点来时，频谱图上升得很快，而在鼓点过后，频谱图下降得很慢。这样就显得更加丝滑！</p>
      <h2 id="更更丝滑的频谱图">更更丝滑的频谱图</h2>
      <p>在前面的实现中，我们默认绘图的字符是 “█”，然而，它在 unicode 中叫作 “Full block”。它还有 7 个兄弟：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">▁</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▂</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▃</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▄</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▅</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▆</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">▇</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">█</span><span class="sh">'</span><span class="p">]</span>
</code></pre>
        </div>
      </div>
      <p>我们可以借此实现更加丝滑的频谱图。</p>
      <p>首先，scale 的最大值可以直接乘以 <code class="language-plaintext highlighter-rouge">len(blocks)</code>：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="n">last_scale_max_val</span> <span class="o">=</span> <span class="nf">int</span><span class="p">((</span><span class="n">max_y</span> <span class="o">*</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">)</span>
</code></pre>
        </div>
      </div>
      <p>然后我们的振幅范围就在 [0, last_scale_max_val] 之间。</p>
      <p>在绘图时，前 <code class="language-plaintext highlighter-rouge">val // len(blocks)</code> 个字符使用 <code class="language-plaintext highlighter-rouge">Full Block</code>，最后一个字符使用 <code class="language-plaintext highlighter-rouge">blocks[val % len(blocks)]</code>。</p>
      <p>我们稍加修改 <code class="language-plaintext highlighter-rouge">draw_spectrum</code> 函数：</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code><span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">colors</span>
    <span class="n">stdscr</span><span class="p">.</span><span class="nf">clear</span><span class="p">()</span>
    <span class="n">half_y</span> <span class="o">=</span> <span class="n">max_y</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">full_1</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">freq</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
        <span class="n">full_2</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">),</span> <span class="nf">len</span><span class="p">(</span><span class="n">colors</span><span class="p">))</span>
        <span class="n">left_1</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">left_2</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="nf">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>

        <span class="c1"># draw the full blocks
</span>        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">full_1</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if the audio file only has one channel, draw the same spectrum for the other channel
</span>                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="k">continue</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">full_2</span><span class="p">):</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

        <span class="c1"># draw the left blocks
</span>        <span class="k">if</span> <span class="n">left_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">left_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_2</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_2</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</code></pre>
        </div>
      </div>
      <video controls="" src="https://blog.soulter.top/images/visualize-music/demo2.5.mp4" title="demo2.5" style="width: 100%"></video>
      <p>OHHH! 看样子更加丝滑了！… 怎么下面的频谱图变得断断续续了？</p>
      <p>因为我们的 blocks 使用的 unicode 字符的填充是从下往上的，因此就会导致在绘制下半部分频谱图时，末端使用的字符方向不对，导致 full block 和其他 block 之间有间隙。怎么解决呢？似乎 unicode 字符没有从上往下填充的字符。</p>
      <p>一个好办法是创造一个 <code class="language-plaintext highlighter-rouge">colors_reverse</code>，其颜色配置和 <code class="language-plaintext highlighter-rouge">colors</code> 相反，比如 colors 中一个 color 的前景是淡蓝色，背景是黑色，那么 colors_reverse 中这个 color 的前景就是黑色，背景就是淡蓝色。然后我们在绘制频谱图时，将下半部分的频谱图字符颜色设置为 <code class="language-plaintext highlighter-rouge">colors_reverse</code> 中的某个。</p>
      <div class="language-py highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code>
<span class="k">def</span> <span class="nf">draw_spectrum</span><span class="p">(</span><span class="n">stdscr</span><span class="p">,</span> <span class="n">spectrum</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># ...
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># ...
</span>        <span class="c1"># draw the left blocks
</span>        <span class="k">if</span> <span class="n">left_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">-</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_1</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors_reverse</span><span class="p">[</span><span class="n">full_1</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">left_2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">stdscr</span><span class="p">.</span><span class="nf">addstr</span><span class="p">(</span><span class="n">half_y</span> <span class="o">+</span> <span class="n">full_2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="n">left_2</span><span class="p">],</span> <span class="n">curses</span><span class="p">.</span><span class="nf">color_pair</span><span class="p">(</span><span class="n">colors_reverse</span><span class="p">[</span><span class="n">full_2</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</code></pre>
        </div>
      </div>
      <p>效果如下：</p>
      <video controls="" src="https://blog.soulter.top/images/visualize-music/demo3.mp4" title="demo3" style="width: 100%"></video>
      <p>快赶上 <code class="language-plaintext highlighter-rouge">ncmpcpp</code> 的效果了！</p>
      <p>后面有时间再继续优化喵。</p>
      <h2 id="附直观理解傅立叶变换">附：直观理解傅立叶变换</h2>
      <p>上文讲到傅立叶变换的基本思想是将一个信号分解为一系列正弦波的叠加。</p>
      <p>拿方波举个例子，下图是一个 5Hz 的方波和一个 5Hz 的正弦波</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976721919.png" alt="" /></p>
      <p>是不是差距蛮大的？那如果我们将 2 个正弦波叠加在一起呢？</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976743585.png" alt="" /></p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725976828380.png" alt="" /></p>
      <p>我们会发现，更像方波了。随着我们叠加的正弦波越来越多，我们的波形就会越来越接近方波。</p>
      <p>我们日常听的音乐就是由大量不同频率的正弦波叠加而成的，而傅立叶变换就能够将其分解为一系列不同频率的波。</p>
      <p>为了直观理解傅立叶变换，我参考了 <a href="https://www.youtube.com/watch?v=spUNpyF58BY">@3b1b 的视频</a> 里的方法。</p>
      <p>还是以 5Hz 的正弦波为例。</p>
      <p>440hz_16bit_5s.wav:</p>
      <audio controls="" src="https://blog.soulter.top/images/visualize-music/440hz_16bit_5s.wav" title="440hz_16bit_5s"></audio>
      <p>我们在复平面上从实数轴正半轴开始逆时针转动一个向量：在任意时刻下，向量的模长等于正弦波的振幅，向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">1 Hz</code>，以此绘制得到一个图：</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725978427291.png" alt="" /></p>
      <p>它的质心用红点标了出来。</p>
      <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">4.2 Hz</code> 时：</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726146180844.png" alt="" /></p>
      <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">4.3 Hz</code> 时：</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1726146113953.png" alt="" /></p>
      <p>当向量的移动速度设置为 <code class="language-plaintext highlighter-rouge">5 Hz</code> 时：</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725979910845.png" alt="" /></p>
      <p>有没有发现什么？我们绘制出质心与原点的距离随向量的移动速度变化的图（我们称为“缠绕图像”）：</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725979995976.png" alt="" /></p>
      <p>在接近 <code class="language-plaintext highlighter-rouge">5 Hz</code> 时，值最大！！</p>
      <p>同样，我们将 5Hz + 15Hz 的正弦波叠加在一起，再次绘制这个图：</p>
      <p><img src="https://blog.soulter.top/images/visualize-music/QQ_1725980156817.png" alt="" /></p>
      <p>极大值点同样出现在 5Hz 和 15Hz 处。</p>
      <p>发生了什么？让我们从公式的角度出发，来解释这个现象。</p>
      <p>由欧拉公式，我们知道，一个圆周运动可以表示为：
        \(e^{2\pi i f t}\)</p>
      <p>其中 $f$ 为频率，$t$ 为时间。</p>
      <p>上述像花一样的缠绕图像可以表示为：</p>
      <p>[g(t) e^{2\pi i t}]</p>
      <p>其中，g(t) 为正弦函数：$ g(t) = \sin(2\pi 5 t) $，也就是一个振幅随时间变化的方程。</p>
      <p>我们需要描述的是其质心在复平面上的坐标的模随时间变化的方程。因此随机取 $N$ 个时间点，计算其质心的坐标，然后取其模长的平均值。</p>
      <table>
        <tbody>
          <tr>
            <td>[\frac{1}{N} \sum_{n=1}^{N}</td>
            <td>g(t_n) e^{2\pi i t_n}</td>
            <td>]</td>
          </tr>
        </tbody>
      </table>
      <p>类似这样，我们对函数作积分，就得到了傅立叶变换：</p>
      <table>
        <tbody>
          <tr>
            <td>[\int_{t_1}^{t_2}</td>
            <td>g(t) e^{2\pi i t}</td>
            <td>dt]</td>
          </tr>
        </tbody>
      </table>
      <p>其值表示的是在 $t_1$ 到 $t_2$ 时刻下，频率为 $f$ 的声波的相对振幅。如果某一个频率的波的强度很大，那么值也会越大。</p>
      <p>看文字不如直接看 <a href="https://www.youtube.com/watch?v=spUNpyF58BY">@3b1b 的视频</a>。</p>
      <h2 id="总结">总结</h2>
      <p>本文介绍了 <code class="language-plaintext highlighter-rouge">wav</code> 的编码结构和傅立叶变换在音频可视化中的应用，并手搓了一个 TUI 的支持频谱可视化的音频播放器。最后，我们通过直观的方式理解了傅立叶变换的基本原理。</p>
      <p>代码开源在了 <a href="https://github.com/soulter/wav-spectrum-visualizer">GitHub</a>，可以去玩玩。</p>
      <h2 id="参考文献">参考文献</h2>
      <p>[1] WAVE File Format. https://web.archive.org/web/20140221054954/http://home.roadrunner.com/~jgglatt/tech/wave.htm</p>
      <p>[2] But what is the Fourier Transform? A visual introduction. https://www.youtube.com/watch?v=spUNpyF58BY</p>
      <p>[3] 为什么要进行傅立叶变换。https://ibillxia.github.io/blog/2013/04/04/why-do-Fourier-transformation/</p>
      ]]></content><author><name>Soulter</name></author><category term="教程" /><category term="音频编码" /><category term="ArchLinux" /><summary type="html"><![CDATA[最近换上了 ArchLinux，体验了众多美观的 TUI 应用。其中我认为最酷炫的当属 ncmpcpp 这个音乐播放器了。]]></summary></entry><entry><title type="html">配置校园网 IPv6 免流</title><link href="https://ustb-806.github.io/blogs/2024/11/ipv6/" rel="alternate" type="text/html" title="配置校园网 IPv6 免流" /><published>2024-11-21T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/ipv6</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/ipv6/"><![CDATA[<p>本文介绍如何在校园网环境内利用教育网 IPv6 进行免流。</p>
    <h2 id="前提">前提</h2>
    <p>校园网免流基于 IPv6 流量不计费，所以要先确定自己使用的无线网/有线网是否支持 IPv6。</p>
    <h2 id="原理">原理</h2>
    <p>校园网同时支持 IPv4 和 IPv6，但是使用 IPV6 并不计费，因此本地通过 IPv6 协议向服务器发送请求，服务器获取到网络资源后再通过 IPv6 将数据发送到本地，就相当于全程使用 IPv6 与互联网进行数据交互。</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629155642916.png" alt="image-20240629155642916" /></p>
    <h2 id="租服务器">租服务器</h2>
    <p>首先我们要租一台代替我们在互联网上下载资源的服务器，或者准确一些，「VPS」。</p>
    <blockquote>
      <p>虚拟专用服务器（Virtual Private Server，简称 VPS）技术，是将一台服务器分割成多个虚拟专享服务器的优质服务。实现 VPS 的技术分为容器技术，和虚拟化技术。在容器或虚拟机中，每个 VPS 都可选配独立公网 IP 地址、独立操作系统、实现不同 VPS 间磁盘空间、内存、CPU 资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。——百度百科</p>
    </blockquote>
    <p>那么该租用一个什么样的 VPS 以及在哪里租比较合适呢？</p>
    <p>首先，为了能够保证网络的流畅，我们要证低延迟和高带宽，此外，我们平时也需要科学上网，但能够找到的机场要么贵要么慢，不妨我们直接搞一个既能科学上网又能免流的 VPS。那么我认为 VPS 的位置最合适的就是香港，不仅能访问到大多数外网的资源又能保证不会在使用免流的时候访问不了国内一些网站。</p>
    <p>那么接下来就是 VPS 租用平台的选取，首先排除阿里云等平台，不仅贵而且带宽仅能给到 30Mb/s。在寻找了一段时间之后，我找到了 <a href="https://churros.cloud/index.php">Churros</a> 这个平台，在这可以租到带宽最多为 625Mb/s。</p>
    <p>注册好账号之后，订购新服务：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163011540.png" alt="image-20240629163011540" /></p>
    <p>选择第一个：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163126172.png" alt="image-20240629163126172" /></p>
    <p>进入之后选择详细的服务：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629163244014.png" alt="image-20240629163244014" /></p>
    <p>其中 CPU 一核，RAM 1G，存储 10G 就够用。带宽 1Gbps 就是上限 125Mb/s。流量根据自己需求选择，记得一定要有一个 IPv6 地址，否则无法免流。下面的系统可以根据自己的偏好选择，这里以 Ubuntu20.04 LTS 为例。</p>
    <p><strong>记得设定一个自己记得住的 root 密码。</strong></p>
    <p>VPS 设定需要几分钟，设定完成之后在终端中输入：</p>
    <div class="language-bash highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code>ssh root@&lt;你的IPv4地址&gt;
</code></pre>
      </div>
    </div>
    <p>弹出 <code class="language-plaintext highlighter-rouge">Are you sure you want to continue connecting (yes/no/[fingerprint])? </code> 输入 <code class="language-plaintext highlighter-rouge">yes</code>，之后输入自己的密码。</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629170451589.png" alt="image-20240629170451589" /></p>
    <p>成功进入 VPS。</p>
    <h2 id="vps-设定">VPS 设定</h2>
    <p>首先，更新 Ubuntu。终端输入：</p>
    <div class="language-bash highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="nb">sudo </span>apt update
<span class="nb">sudo </span>apt <span class="nb">install </span>curl
<span class="nb">sudo </span>apt <span class="nb">install </span>socat
<span class="nb">sudo </span>apt <span class="nb">install </span>ufw
</code></pre>
      </div>
    </div>
    <h3 id="安装-x-ui">安装 X-UI</h3>
    <p>终端输入：</p>
    <div class="language-bash highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code>bash &lt;<span class="o">(</span>curl <span class="nt">-Ls</span> https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh<span class="o">)</span>
</code></pre>
      </div>
    </div>
    <p>依次设置账号密码和端口：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629171501501.png" alt="image-20240629171501501" /></p>
    <p>这里我自定义了端口为 <code class="language-plaintext highlighter-rouge">54321</code>，实际上任何端口都可以，自己能记住即可，不必完全相同。</p>
    <h3 id="开放-ufw-防火墙端口">开放 ufw 防火墙端口</h3>
    <div class="language-bash highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="nb">sudo </span>ufw status   <span class="c"># 查看本地端口开启情况</span>
<span class="nb">sudo </span>ufw <span class="nb">enable</span>   <span class="c"># 开启防火墙，允许访问特定端口</span>
<span class="nb">sudo </span>ufw allow 20
<span class="nb">sudo </span>ufw allow 21
<span class="nb">sudo </span>ufw allow 22
<span class="nb">sudo </span>ufw allow 54321/tcp  <span class="c"># 给 X-UI 面板开放端口</span>
<span class="nb">sudo </span>ufw allow 12345/tcp  <span class="c"># 给后续的 v2ray 开放端口</span>
                          <span class="c"># 如果多人使用根据自己需求再开启几个</span>
<span class="nb">sudo </span>ufw status  <span class="c"># 重新检查端口开放情况</span>
</code></pre>
      </div>
    </div>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629204716087.png" alt="image-20240629204716087" /></p>
    <h3 id="开启-bbr-加速">开启 BBR 加速</h3>
    <p>新的 TCP 拥塞控制算法 BBR (Bottleneck Bandwidth and RTT) 可以让服务器的带宽尽量跑满，并且尽量不要有排队的情况，让网络服务更佳稳定和高效。</p>
    <div class="language-bash highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code><span class="nb">echo </span>net.core.default_qdisc<span class="o">=</span>fq <span class="o">&gt;&gt;</span> /etc/sysctl.conf
<span class="nb">echo </span>net.ipv4.tcp_congestion_control<span class="o">=</span>bbr <span class="o">&gt;&gt;</span> /etc/sysctl.conf   <span class="c"># 修改系统变量</span>
sysctl <span class="nt">-p</span>   <span class="c"># 保存</span>
</code></pre>
      </div>
    </div>
    <p>接下来检查是否开启成功。</p>
    <p>分别输入：</p>
    <div class="language-bash highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code>sysctl net.ipv4.tcp_available_congestion_control
lsmod | <span class="nb">grep </span>bbr
</code></pre>
      </div>
    </div>
    <p>如果第一个输出：</p>
    <div class="language-bash highlighter-rouge">
      <div class="highlight">
        <pre class="highlight"><code>sysctl net.ipv4.tcp_available_congestion_control
net.ipv4.tcp_available_congestion_control <span class="o">=</span> bbr cubic reno
</code></pre>
      </div>
    </div>
    <p>第二个有输出结果（如果失败不会有输出结果）就说明 BBR 开启成功了。</p>
    <h3 id="配置-x-ui">配置 X-UI</h3>
    <p>在浏览器中输入 <code class="language-plaintext highlighter-rouge">&lt;IPv4地址&gt;:&lt;端口号&gt;</code></p>
    <p>如 <code class="language-plaintext highlighter-rouge">103.229.54.***:54321</code> 进行登录</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629190947466.png" alt="image-20240629190947466" /></p>
    <p>在入站列表中配置：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629191636631.png" alt="image-20240629191636631" /></p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629191629249.png" alt="image-20240629191629249" /></p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192247486.png" alt="image-20240629192247486" /></p>
    <p>在操作中点击「二维码」，然后复制：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192346320.png" alt="image-20240629192346320" /></p>
    <h2 id="配置客户端">配置客户端</h2>
    <p>VPS 的配置已经完成，接下来就是要在电脑上使用。</p>
    <h3 id="v2ray-配置">V2ray 配置</h3>
    <p>V2ray 下载：<a href="https://github.com/2dust/v2rayN/releases/download/4.26/v2rayN-Core.zip">下载链接</a>。</p>
    <p>下载后解压，双击「v2rayN」运行。</p>
    <p>在 V2ray 中点击「服务器」，「从剪贴板导入批量 url」</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192535573.png" alt="image-20240629192535573" /></p>
    <p>导入成功如下：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192723613.png" alt="image-20240629192723613" /></p>
    <p>双击，进入编辑，将 IPv4 地址替换为自己的 IPv6 地址：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629192853962.png" alt="image-20240629192853962" /></p>
    <p>如下：</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193011319.png" alt="image-20240629193011319" /></p>
    <p>点击确定进行保存。</p>
    <p>在任务栏右侧找到 V2ray 的图标，在「服务器」中选择自己的服务器，「系统代理」中选择「自动配置系统代理」，「路由」中选择「全局」。</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193446792.png" alt="image-20240629193446792" /></p>
    <p>在任务管理器中查看网络使用情况，如果全都是 V2ray 用的就代表配置成功了。可以肆意上网了。</p>
    <p><img src="https://blog-s3.806.group/post/2024/2024-11-21-ipv6/image-20240629193435397.png" alt="image-20240629193435397" /></p>
    <h2 id="全文完">全文完</h2>
    <blockquote>
      <p>原文链接：<a href="https://fridemn.best/archives/xiao-yuan-wang-mian-liu">https://fridemn.best/archives/xiao-yuan-wang-mian-liu</a></p>
    </blockquote>
    ]]></content><author><name>Fridemn</name></author><category term="教程" /><category term="校园网" /><category term="IPv6" /><summary type="html"><![CDATA[本文介绍如何在校园网环境内利用教育网 IPv6 进行免流。]]></summary></entry><entry><title type="html">如何在 Linux 上部署一个 MC 纯净/整合包服务器</title><link href="https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux/" rel="alternate" type="text/html" title="如何在 Linux 上部署一个 MC 纯净/整合包服务器" /><published>2024-11-20T00:00:00+08:00</published><updated>2025-01-21T21:03:46+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/how-to-setup-mc-server-on-linux/"><![CDATA[<blockquote>
    <p>作为 806 系统部的一员，能够在 Linux 服务器上部署一个 MC 服务端是所有人必须要会的技能。——系统部传统</p>
  </blockquote>
  <p>要想和好基友们开黑 MC，一般会采用单人游戏 + 对局域网开放的方式。但是这样有一个弊端：每次游戏的时候都需要主机在线，这对于随时随地都可能想上线种田的大四老登来说是不可容忍的，而 806 正好又不缺服务器，所以在服务器上部署一个 MC 服务端是更合适的方式。</p>
  <p>本文的环境是：</p>
  <ul>
    <li>Ubuntu 24.04 LTS</li>
    <li><a href="https://www.mcmod.cn/modpack/273.html">冬季救援整合包</a>（1.16.5 Forge）</li>
  </ul>
  <p>一些背景知识：</p>
  <ul>
    <li>连接服务器使用 SSH，这里推荐一个很好用的 SSH 客户端 <a href="https://mobaxterm.mobatek.net/">MobaXTerm</a>，其能直接通过自带的 sftp 工具传输文件。</li>
    <li>在服务器上下载文件可以使用 <code class="language-plaintext highlighter-rouge">wget</code>，复制想要下载的文件的链接，直接在终端输入 <code class="language-plaintext highlighter-rouge">wget &lt;下载链接&gt;</code> 回车即可。</li>
    <li>启动游戏推荐使用第三方客户端，这里推荐 <a href="https://afdian.com/p/0164034c016c11ebafcb52540025c377">PCL</a> 和 <a href="https://hmcl.huangyuhui.net/">HMCL</a>，尽量不要用官方启动器，功能贫乏。</li>
  </ul>
  <h2 id="配置-java-环境">配置 Java 环境</h2>
  <p>MC 是用 Java 写的，所以配置 Java 环境也很合理。</p>
  <p>安装 Java 运行环境之前，首先需要知道想要运行的 MC 版本对应的 Java 版本是多少，这里搬运 <a href="https://zh.minecraft.wiki/w/Tutorial:%E6%9B%B4%E6%96%B0Java?variant=zh-cn">MC 官方 Wiki</a> 里关于 Java 版本的说明：</p>
  <table>
    <thead>
      <tr>
        <th>Minecraft 开发版本</th>
        <th>Minecraft 正式版本</th>
        <th>最低要求 Java 版本</th>
        <th>官启绑定 Java 版本</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/24w14a">24w14a</a>及以上</td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.20.5">1.20.5</a>及以上</td>
        <td>Java 21</td>
        <td>21.0.3</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/22w18a">22w18a</a>至<a href="https://zh.minecraft.wiki/w/24w13a">24w13a</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.19">1.19</a>至<a href="https://zh.minecraft.wiki/w/Java版1.20.4">1.20.4</a></td>
        <td>Java 17</td>
        <td>17.0.8</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.18-pre2">1.18-pre2</a>至<a href="https://zh.minecraft.wiki/w/22w17a">22w17a</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.18">1.18</a>至<a href="https://zh.minecraft.wiki/w/Java版1.18.2">1.18.2</a></td>
        <td>Java 17</td>
        <td>17.0.1</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/21w19a">21w19a</a>至<a href="https://zh.minecraft.wiki/w/Java版1.18-pre1">1.18-pre1</a></td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.17">1.17</a>至<a href="https://zh.minecraft.wiki/w/Java版1.17.1">1.17.1</a></td>
        <td>Java 16</td>
        <td>16.0.1</td>
      </tr>
      <tr>
        <td><a href="https://zh.minecraft.wiki/w/21w18a">21w18a</a>及以下</td>
        <td><a href="https://zh.minecraft.wiki/w/Java版1.16.5">1.16.5</a>及以下</td>
        <td>Java 8</td>
        <td>1.8.0_51</td>
      </tr>
    </tbody>
  </table>
  <p>由于我需要运行的版本是 1.16.5，因此这里需要安装 Java 8。</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>openjdk-8-jdk
</code></pre>
    </div>
  </div>
  <p>对于其他的 Java 版本，一般来说将上面指令中的 <code class="language-plaintext highlighter-rouge">8</code> 替换成对应的版本号就可以了。</p>
  <p>安装完成后可以使用 <code class="language-plaintext highlighter-rouge">java --version</code> 来查看版本是否正确。</p>
  <p>如果服务器同时安装了多个版本的 Java，可以使用下面的指令来切换默认的 Java 版本：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>update-alternatives <span class="nt">--config</span> java
</code></pre>
    </div>
  </div>
  <h2 id="配置服务端">配置服务端</h2>
  <p>对于原版、Forge 和 Fabric，初始化服务端的方式各不相同。</p>
  <p>国内的 MCSL 维护了一套服务端文件的镜像（<a href="https://sync.mcsl.com.cn/">这里</a>），后文讲到的文件可以先在这里尝试下载。</p>
  <h3 id="原版vanilla">原版（Vanilla）</h3>
  <p>MC 原版的服务端文件可以直接在 Minecraft 官网上下载。直接 Bing/Google 搜索 <code class="language-plaintext highlighter-rouge">minecraft server &lt;版本号&gt; 下载</code>，找到官方网站对应的下载链接即可。下载下来的服务端一般是一个名为 <code class="language-plaintext highlighter-rouge">server.jar</code>的 jar 文件。</p>
  <p>需要注意两点：</p>
  <ul>
    <li>不要用百度，百度只会把你导航到网易（MC 的国内代理，但是依托**）。</li>
    <li>进入官网后，如果你没有挂梯子的话，那么同样会弹窗让你跳转到网易，注意点击下方的 <code class="language-plaintext highlighter-rouge">Stay on Minecraft.net</code> 留在国际版官网。</li>
  </ul>
  <p>当然，也可以使用上面提到的 <a href="https://sync.mcsl.com.cn/core/Vanilla">MCSL 镜像源</a>下载。</p>
  <p>接下来找到一个合适的目录，初始化服务端：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> server.jar nogui
</code></pre>
    </div>
  </div>
  <p>第一次运行服务端，会创建一个 <code class="language-plaintext highlighter-rouge">eula.txt</code>然后报错退出，这个文件的作用是同意许可。使用 vim 或 nano 或其他方式打开，将里面的 <code class="language-plaintext highlighter-rouge">false</code> 改成 <code class="language-plaintext highlighter-rouge">true</code>，保存退出，重新启动即可。</p>
  <p>等到终端出现 <code class="language-plaintext highlighter-rouge">Done!</code> 等文字的时候，说明服务器已经成功启动，此时已经可以直接开始玩了。不过后面会配置一些优化体验的东西，请继续阅读下文。</p>
  <h3 id="forge">Forge</h3>
  <p>Forge 端可以在 <a href="https://files.minecraftforge.net/net/minecraftforge/forge/">Forge 官网</a>上下载（可能需要挂梯子）。当然，也可以使用上面提到的 <a href="https://sync.mcsl.com.cn/core/Forge">MCSL 镜像源</a>下载。</p>
  <p><strong>注意</strong>：Forge 的小版本之间也会出现不兼容的情况，所以如果是配置整合包的话，一定要下载和整合包的 Forge 版本完全一致的服务端。</p>
  <p>下载下来后会得到一个名为 <code class="language-plaintext highlighter-rouge">forge-&lt;游戏版本&gt;-&lt;Forge版本&gt;-installer.jar</code> 的文件。这里我下载的文件名为 <code class="language-plaintext highlighter-rouge">forge-1.16.5-36.2.34-installer.jar</code>。</p>
  <p>找到一个合适的目录，启动：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> forge-1.16.5-36.2.34-installer.jar <span class="nt">--installServer</span>  <span class="c"># 注意要把文件替换为自己下载的</span>
</code></pre>
    </div>
  </div>
  <p>接下来 Forge Installer 会下载一系列文件，包括服务端原始文件，然后自动进行配置。这个阶段需要保持服务器有良好的网络。该过程有可能需要翻墙。</p>
  <p>配置完成之后，会留下一些文件，其中最重要的是三个（注意替换成自己的版本号）：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">forge-1.16.5-36.2.34.jar</code>：Forge 的主体文件，也是 Forge 端运行的入口；</li>
    <li><code class="language-plaintext highlighter-rouge">libraries</code>：资源文件；</li>
    <li><code class="language-plaintext highlighter-rouge">minecraft_server.1.16.5.jar</code>：Forge 运行的服务端文件。</li>
  </ul>
  <p>接下来就可以启动服务器了：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> forge-1.16.5-36.2.34.jar nogui  <span class="c"># 注意把文件替换为自己的</span>
</code></pre>
    </div>
  </div>
  <p>和原版服务器一样，第一次启动会创建 <code class="language-plaintext highlighter-rouge">eula.txt</code> 文件并报错退出，需要将该文件里面的 <code class="language-plaintext highlighter-rouge">false</code> 修改为 <code class="language-plaintext highlighter-rouge">true</code> 保存退出，重新启动即可。</p>
  <p>重新启动服务器后，服务器会生成一系列游戏文件，包括存档文件夹 <code class="language-plaintext highlighter-rouge">world</code> 和放置 mod 的文件夹 <code class="language-plaintext highlighter-rouge">mods</code>。只需要将想要添加的 mod 放入 <code class="language-plaintext highlighter-rouge">mods</code> 文件夹，重新启动，即可加载 mod。</p>
  <p>不过如果是想配置整合包的话，还需要做接下来的工作。</p>
  <p>整合包一般分为两种发布方法，一种是直接把整个游戏打成压缩包，而另一种是采用配置文件压缩包的形式（压缩包内部有一个 <code class="language-plaintext highlighter-rouge">overrides</code> 文件夹，需要从 PCL 等第三方启动器的 <code class="language-plaintext highlighter-rouge">导入整合包</code> 来进行导入）：</p>
  <ul>
    <li>对于第一种方法，需要将压缩包内的 <code class="language-plaintext highlighter-rouge">mods</code>文件夹和所有的与「配置」相关的文件夹都复制到服务器目录下（包括但不限于 <code class="language-plaintext highlighter-rouge">config</code>、<code class="language-plaintext highlighter-rouge">kubejs</code>、<code class="language-plaintext highlighter-rouge">scripts</code>）。<strong>这一步很重要，如果漏掉了任何一个配置文件都可能会导致整合包运行不正确，所以务必仔细检查。</strong></li>
    <li>而对于第二种方法，首先在本地客户端导入整合包，在本地安装完之后，进入游戏版本根目录，将 <code class="language-plaintext highlighter-rouge">mods</code> 文件夹复制到服务器目录下。然后，将配置文件压缩包里 <code class="language-plaintext highlighter-rouge">overrides</code>文件夹下的所有文件复制到服务器目录下即可。</li>
  </ul>
  <p>完成上述操作后，将刚刚启动生成的 <code class="language-plaintext highlighter-rouge">world</code> 文件夹删除（如果没有就不用管了，这一步是因为整合包可能会对地图生成进行改动，需要将原版生成的地图删除了重新生成），重新启动服务端即可。</p>
  <h3 id="fabric">Fabric</h3>
  <p>Fabric 和 Forge 的安装步骤除了下载文件以外基本上相同。</p>
  <p>相比于 Forge 完全不提供中文安装教程，Fabric 提供了一个非常友好的<a href="https://wiki.fabricmc.net/zh_cn:player:tutorials:install_server">官方中文安装教程</a>，请参考这个教程进行安装，然后跳转到 <a href="#forge">Forge 章节</a>的整合包配置部分。</p>
  <h2 id="更多的配置可选">更多的配置（可选）</h2>
  <p>进行完上述的步骤后，服务器文件夹下大致会有以下文件：</p>
  <p><img src="https://blog-s3.806.group/post/2024/2024-11-20-how-to-setup-mc-server-on-linux/1.png" alt="" /></p>
  <p>我配置的是 Forge 整合包服务器，所以文件会多出许多，但大致的内容都差不多，多一些少一些差别不大。</p>
  <p>其中和整合包 mod 配置相关的文件有：<code class="language-plaintext highlighter-rouge">config</code>，<code class="language-plaintext highlighter-rouge">kubejs</code>，<code class="language-plaintext highlighter-rouge">defaultconfigs</code>，<code class="language-plaintext highlighter-rouge">worldshape</code>；</p>
  <p>此时，其实就可以启动服务器开始玩了！但是我们还可以再进一步配置一些东西更方便我们运维。</p>
  <h3 id="screen">Screen</h3>
  <p>启动服务器的时候可以使用 screen、tmux 等工具将其挂在后台，这样就可以切断 SSH 连接而不会导致服务器关闭。接下来简单介绍 screen。</p>
  <p>首先安装 screen：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>screen
</code></pre>
    </div>
  </div>
  <p>可以通过指令 <code class="language-plaintext highlighter-rouge">screen</code> 启动一个新的 screen 会话。可以发现，screen 会话和普通的终端没有什么不同，因为其直接沿用了当前终端的配置。不过，screen 会话可以通过快捷键 <code class="language-plaintext highlighter-rouge">&lt;Ctrl-A&gt; + z</code> 来挂起当前会话，通过指令 <code class="language-plaintext highlighter-rouge">screen -r</code> 来重新连接挂起的会话。</p>
  <p>这样每次使用 screen 启动服务器之后，就可以直接关闭终端，让服务器在后台继续运行，下次需要运维的时候重新连接回来即可。</p>
  <h3 id="serverproperties">server.properties</h3>
  <p><code class="language-plaintext highlighter-rouge">server.properties</code> 文件是 MC 服务器的配置文件。我们可以更改里面的一些内容来实现更好的效果：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">allow-flight</code>：建议改为 <code class="language-plaintext highlighter-rouge">true</code>，因为很多整合包提供了飞行的能力，如果不开启的话会被服务器误认为是在作弊而直接踢出；</li>
    <li><code class="language-plaintext highlighter-rouge">difficulty</code>：服务器的难度，有 <code class="language-plaintext highlighter-rouge">peaceful</code>、<code class="language-plaintext highlighter-rouge">easy</code>、<code class="language-plaintext highlighter-rouge">normal</code>和 <code class="language-plaintext highlighter-rouge">hard</code> 四个选项；</li>
    <li><code class="language-plaintext highlighter-rouge">motd</code>：服务器显示在游戏内的说明文字；</li>
    <li><code class="language-plaintext highlighter-rouge">pvp</code>：玩家之间是否相互可以攻击；</li>
    <li><code class="language-plaintext highlighter-rouge">server-port</code>：服务器的端口，如果一台机子上需要运行多个服务器的话，需要分别设置不同的端口才能运行，否则会冲突。</li>
    <li><code class="language-plaintext highlighter-rouge">online-mode</code>：正版验证，开启了的话需要服务器联网才能加入，好处是能有皮肤。</li>
    <li><code class="language-plaintext highlighter-rouge">view-distance</code>：服务器渲染的视距，依照服务器的性能进行调整，如果卡了就调低一点；</li>
  </ul>
  <h3 id="启动参数">启动参数</h3>
  <p>启动服务器的时候可以在 java 指令后添加一些参数来优化性能，这里我只设置了服务器的内存：</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code>java <span class="nt">-jar</span> <span class="nt">-Xmx16G</span> <span class="nt">-Xms16G</span> server.jar nogui
</code></pre>
    </div>
  </div>
  <p>其中：</p>
  <ul>
    <li><code class="language-plaintext highlighter-rouge">-Xmx</code>：设置最大内存；</li>
    <li><code class="language-plaintext highlighter-rouge">-Xms</code>：设置最小内存；</li>
    <li><code class="language-plaintext highlighter-rouge">nogui</code>：以命令行模式启动，必须要添加，否在在命令行里会报错。</li>
  </ul>
  <h3 id="开放防火墙端口">开放防火墙端口</h3>
  <p>由于 Ubuntu 默认开启了防火墙 ufw，所以需要在防火墙开放 MC 服务器默认的端口 <code class="language-plaintext highlighter-rouge">25565</code> 才能链接到服务器。</p>
  <div class="language-bash highlighter-rouge">
    <div class="highlight">
      <pre class="highlight"><code><span class="nb">sudo </span>ufw allow 25565  <span class="c"># 开放 25565 端口</span>
</code></pre>
    </div>
  </div>
  <p>如果服务器使用了其他的端口的话，需要改成开放对应的其他端口。</p>
  <h3 id="记分板">记分板</h3>
  <p>你可能在看别的人玩服务器的时候发现，可以在 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 键的玩家列表里看到所有玩家的血量，在显示屏右边有一个榜单显示当前死亡数等……这些都是通过原版的记分板实现的。</p>
  <p>在 MC 服务端的控制台输入以下指令：</p>
  <ul>
    <li>
      <p>启用 <code class="language-plaintext highlighter-rouge">&lt;Tab&gt;</code> 显示血量：</p>
      <div class="language-text highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code>scoreboard objectives add health health "血量"
scoreboard objectives setdisplay list health
</code></pre>
        </div>
    </div>
    </li>
    <li>
      <p>启用侧边栏死亡计数：</p>
      <div class="language-text highlighter-rouge">
        <div class="highlight">
          <pre class="highlight"><code>scoreboard objectives add deathCount deathCount "死亡数"
scoreboard objectives setdisplay sidebar deathCount
</code></pre>
        </div>
    </div>
    </li>
  </ul>
  <h2 id="配置-mcdreforged可选">配置 MCDReforged（可选）</h2>
  <p>接下来我们会配置一个非常好用的 MC 服务端管理工具 <a href="https://mcdreforged.com/zh-CN">MCDReforged</a>。这个工具是 TIS 服务器开发的，能够在不修改原版任何东西的基础上，给服务端添加很多很好用的功能，比如：自动备份、自动启停、显示玩家位置等。</p>
  <p>MCDReforged 的安装请参考<a href="https://docs.mcdreforged.com/zh-cn/latest/quick_start/index.html">官方手册</a>。注意，安装方式最好选择 pipx，实测在 Ubuntu 24.04 LTS 下只能使用 pipx 安装方式。</p>
  <p>配置好后，每次启动服务器就是在 MCDReforged 的目录下使用指令 <code class="language-plaintext highlighter-rouge">mcdreforged</code> 启动。</p>
  <p>除了接管 MC 那难用的控制台以外，MCDReforged 最好用的功能就是丰富的插件生态。可以查看<a href="https://mcdreforged.com/zh-CN/plugins">官方插件仓库</a>来查找自己喜欢的插件。这里我列举我每次都会安装的几个插件：</p>
  <ul>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/info">Info</a>：能够获取当前服务器的各种信息，例如 CPU 利用率、内存使用率、存档大小等。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/where2go">Where2go</a>：一个功能强大的位置插件，包含共享坐标点、查询玩家位置等功能。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/prime_backup">Prime Backup</a>：一个强大的 MCDR 备份插件，一套先进的 Minecraft 存档备份解决方案。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/hibernate_r/readme">HibernateR</a>：在服务器没有人的时候让服务器休眠，有人连接时开启。</li>
    <li><a href="https://mcdreforged.com/zh-CN/plugin/simple_op">Simple OP</a>：<code class="language-plaintext highlighter-rouge">!!op</code> 以获取 op, <code class="language-plaintext highlighter-rouge">!!restart</code> 以重启服务器。</li>
  </ul>
  <h2 id="本文完">本文完</h2>
  <p>最后是夹带私货时间！</p>
  <p class="text-center"><img src="https://blog-s3.806.group/post/2024/2024-11-20-how-to-setup-mc-server-on-linux/banner.png" alt="" />
    猜猜这些都是谁？（提示：全部都是 806 系统部成员）</p>
  <blockquote>
    <p>原文链接：https://blog.bosswnx.xyz/posts/2024/how-to-setup-mc-server-on-linux/</p>
  </blockquote>
  ]]></content><author><name>Nelson Boss</name></author><category term="教程" /><category term="Minecraft" /><category term="Linux" /><summary type="html"><![CDATA[作为 806 系统部的一员，能够在 Linux 服务器上部署一个 MC 服务端是所有人必须要会的技能。——系统部传统]]></summary></entry><entry><title type="html">OceanBase 2024 比赛资源汇总</title><link href="https://ustb-806.github.io/blogs/2024/11/oceanbase/" rel="alternate" type="text/html" title="OceanBase 2024 比赛资源汇总" /><published>2024-11-12T00:00:00+08:00</published><updated>2024-12-10T00:04:26+08:00</updated><id>https://ustb-806.github.io/blogs/2024/11/oceanbase</id><content type="html" xml:base="https://ustb-806.github.io/blogs/2024/11/oceanbase/"><![CDATA[<p>全国大学生计算机系统能力大赛（OceanBase 数据库大赛）于 2024/10/18 正式开始。下面汇总了比赛的各种资源、赛后总结以供大家参考。</p>
  <h2 id="初赛miniob">初赛（MiniOB）</h2>
  <p>资源信息：</p>
  <ul>
    <li>比赛链接：<a href="https://open.oceanbase.com/train?questionId=600010">MiniOB 训练营</a></li>
    <li><a href="https://open.oceanbase.com/competition/armory">数据库大赛英雄榜</a></li>
    <li><a href="https://oceanbase.github.io/miniob/">MiniOB 辅助开发手册</a></li>
    <li><a href="https://www.oceanbase.com/docs/-developer-quickstart-10000000000627360">MiniOB 官方手册</a></li>
    <li>MiniOB 官方教学视频：
      <ul>
        <li><a href="https://www.oceanbase.com/video/9000654">1-1 数据库系统概述…</a></li>
        <li><a href="https://open.oceanbase.com/activities/4921877?id=4921946">从 0 到 1 数据库内核实战教程</a></li>
      </ul>
    </li>
  </ul>
  <p>实用工具：</p>
  <ul>
    <li>MySQL 语法：<a href="https://www.runoob.com/sql/sql-syntax.html">SQL 语法 - 菜鸟教程</a></li>
    <li>在线运行 MySQL：<a href="https://onecompiler.com/mysql/">MySQL - OneCompiler</a></li>
  </ul>
  <p>赛后总结：</p>
  <table>
    <thead>
      <tr>
        <th>队伍 &amp; GitHub 仓库</th>
        <th>成员</th>
        <th>总结</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="https://github.com/bosswnx/miniob-2024">我真的参加了系统内核赛</a></td>
        <td>王诺贤</td>
        <td><a href="https://zhuanlan.zhihu.com/p/5953505884">OceanBase 2024 初赛 MiniOB 开发记录</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>廖玮珑</td>
        <td><a href="https://blog.soulter.top/posts/2024-oceanbase-database.html">OceanBase 数据库内核实现赛 / 自己实现一个数据库</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>陈渠</td>
        <td><a href="https://blog.virtualfuture.top/posts/miniob/">OceanBase 数据库大赛初赛结束之后</a></td>
      </tr>
      <tr>
        <td><a href="https://github.com/SaZiKK/miniob-2024">我一定要参加编译系统实现赛</a></td>
        <td>陈宽宽</td>
        <td><a href="https://sazikk.github.io/posts/%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97-OceanBase%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%83%BD%E5%8A%9B%E5%A4%A7%E8%B5%9B%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/">【开发日志】OceanBase 数据库系统能力大赛开发日志</a></td>
      </tr>
      <tr>
        <td> </td>
        <td>刁明轩</td>
        <td><a href="https://dmx20070206.github.io/2024/11/11/miniob/">miniob 初赛参赛总结</a></td>
      </tr>
    </tbody>
  </table>
  <h2 id="决赛oceanbase">决赛（OceanBase）</h2>
  <p>信息汇总中……</p>
  ]]></content><author><name>USTB-806</name></author><category term="竞赛" /><category term="计算机系统能力大赛" /><category term="OceanBase" /><summary type="html"><![CDATA[全国大学生计算机系统能力大赛（OceanBase 数据库大赛）于 2024/10/18 正式开始。下面汇总了比赛的各种资源、赛后总结以供大家参考。]]></summary></entry></feed>